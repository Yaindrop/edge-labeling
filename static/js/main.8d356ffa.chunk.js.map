{"version":3,"sources":["model.ts","controller.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["bgMat","edgeMat","labelMat","roiRect","bgRoi","edgeRoi","labelRoi","display","Pos","dist","v1","v2","Math","sqrt","pow","add","sub","mul","v","m","sum","vecs","reduce","prev","curr","nbrs","p","closeNbrs","getVal","mat","pos","cols","rows","ucharPtr","fallPos","earlyStop","curPos","curVal","r","vals","map","maxNbrVal","max","maxNbrs","i","filter","_","includes","direction","length","dists","indexOf","min","isBranch","changes","selectTillBranch","inclusive","res","stack","visited","push","pop","toString","edgeNbrs","branchedNbrs","forEach","needRepair","fillSelect","mats","hitWall","imshow","cv","composeDisplay","config","copyTo","showEdge","edgeCvted","Mat","zeros","type","showEdgeValley","threshold","THRESH_BINARY","cvtColor","COLOR_GRAY2RGBA","addWeighted","bgWeight","edgeWeight","delete","labelThresed","labelCvted","labelColorInv","labelColor","c","subtract","growValley","ones","CV_8U","dilated","dilate","Point","BORDER_CONSTANT","morphologyDefaultBorderValue","getRoi","setRoi","roi","x","y","width","height","DEFAULT_COMPOSE","composeUpdate","BehaviorSubject","roiUpdate","Subject","srcUpdate","edgeUpdate","labelUpdate","displayUpdate","MatUtilImpl","setVal","val","set","dimBy","amount","dimMask","pipe","subscribe","value","tap","src","imread","COLOR_RGB2GRAY","Canny","next","util","update","ValidCursorModes","0","1","2","3","4","5","CursorColors","hist","getRelPos","canvas","e","rect","getBoundingClientRect","clientX","left","clientY","top","getRoiPos","relPos","floor","App","useState","isFocused","setFocused","actionMode","setActionMode","cursorMode","setCursorMode","isMouseDown","setMouseDown","movePrevPos","setMovePrevPos","imageSrc","useRef","doAction","useCallback","targets","pressed","action","range","j","undo","h","onImageLoad","currentTarget","onCanvasMouseEnter","onCanvasMouseLeave","onCanvasMouseMove","onCanvasMouseDown","onCanvasMouseUp","setModes","newCursorMode","newActionMode","onCanvasKeyPress","key","onCanvasFocus","onCanvasBlur","className","id","alt","ref","onLoad","style","name","onChange","current","URL","createObjectURL","target","files","Group","disabled","Button","ghost","onClick","onMouseEnter","onMouseLeave","onMouseMove","onMouseDown","onMouseUp","onKeyPress","onFocus","onBlur","tabIndex","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"iHAEIA,EACAC,EACAC,EAEAC,EAEAC,EACOC,EACAC,EACAC,E,8HAUEC,EAAM,CACfC,KAAM,SAACC,EAAcC,GAAf,OAAgCC,KAAKC,KAAKD,KAAKE,IAAIJ,EAAG,GAAKC,EAAG,GAAI,GAAKC,KAAKE,IAAIJ,EAAG,GAAKC,EAAG,GAAI,KACrGI,IAAK,SAACL,EAAcC,GAAf,MAAgC,CAACD,EAAG,GAAKC,EAAG,GAAID,EAAG,GAAKC,EAAG,KAChEK,IAAK,SAACN,EAAcC,GAAf,MAAgC,CAACD,EAAG,GAAKC,EAAG,GAAID,EAAG,GAAKC,EAAG,KAChEM,IAAK,SAACC,EAAaC,GAAd,MAA4B,CAACD,EAAE,GAAKC,EAAGD,EAAE,GAAKC,IACnDC,IAAK,SAACC,GAAD,OAAsBA,EAAKC,QAAO,SAACC,EAAMC,GAAP,OAAgBhB,EAAIO,IAAIQ,EAAMC,KAAO,CAAC,EAAG,KAChFC,KAAM,SAACC,GAAD,MAAiB,CACnB,CAACA,EAAE,GAAK,EAAGA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAIA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAK,EAAGA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAK,EAAGA,EAAE,IAC3E,CAACA,EAAE,GAAK,EAAGA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAIA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAK,EAAGA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAK,EAAGA,EAAE,MAE/EC,UAAW,SAACD,GAAD,MAAiB,CACxB,CAACA,EAAE,GAAIA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAK,EAAGA,EAAE,IAC/B,CAACA,EAAE,GAAIA,EAAE,GAAK,GAAI,CAACA,EAAE,GAAK,EAAGA,EAAE,OAI1BE,EAAS,SAACC,EAAUC,GAC7B,OAAIA,EAAI,IAAM,GAAKA,EAAI,IAAM,GAAKA,EAAI,GAAKD,EAAIE,MAAQD,EAAI,GAAKD,EAAIG,KACzDH,EAAII,SAASH,EAAI,GAAIA,EAAI,IAAI,GACjC,GAGEI,EAAU,SAACL,EAAUC,GAAsC,IAAvBK,EAAsB,0DAC5C,CAACL,EAAKF,EAAOC,EAAKC,IAApCM,EAD8D,KACtDC,EADsD,KAEnE,GAAe,IAAXA,EAAc,OAAOD,EACzB,IAHmE,eAG1DE,GACL,IAAIb,EAAOjB,EAAIiB,KAAKW,GAChBG,EAAOd,EAAKe,KAAI,SAAAV,GAAG,OAAIF,EAAOC,EAAKC,MACjCW,EAAY7B,KAAK8B,IAAL,MAAA9B,KAAI,YAAQ2B,IAC9B,GAAIE,IAAcJ,EAAQ,cAC1B,IAAMM,EAAUJ,EAAKC,KAAI,SAACtB,EAAG0B,GAAJ,OAAU1B,IAAMuB,EAAYG,GAAK,KAAGC,QAAO,SAAAD,GAAC,OAAIA,GAAK,KAC9E,GAAIT,GAA2B,MAAdM,EAAmB,cACpCF,EAAOA,EAAKM,QAAO,SAACC,EAAGF,GAAJ,OAAUD,EAAQI,SAASH,MAC9CnB,EAAOA,EAAKoB,QAAO,SAACC,EAAGF,GAAJ,OAAUD,EAAQI,SAASH,MAC9C,IAAMI,EAAYxC,EAAIQ,IAAIR,EAAIS,IAAIT,EAAIY,IAAIK,GAAO,EAAIkB,EAAQM,QAASb,GAChEc,EAAQzB,EAAKe,KAAI,SAAAV,GAAG,OAAItB,EAAIC,KAAKqB,EAAKkB,MAG5C,OAFAZ,EAASX,EAAKyB,EAAMC,QAAQvC,KAAKwC,IAAL,MAAAxC,KAAI,YAAQsC,MAEzB,OADfb,EAASI,GACW,aAApB,GAbKH,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAAC,IAAD,IAApBA,GAAoB,eAaL,MAExB,OAAOF,GAGLiB,EAAW,SAACxB,EAAUC,GACxB,IACIS,EADO/B,EAAIiB,KAAKK,GACJU,KAAI,SAAAd,GAAC,OAAIE,EAAOC,EAAKH,MAAIc,KAAI,SAAAtB,GAAC,OAAU,MAANA,EAAY,EAAI,KAC9DoC,EAAU,EACd,GAAKf,EAAK,IAAMA,EAAK,IAAMA,EAAK,IAC3BA,EAAK,IAAMA,EAAK,IAAMA,EAAK,IAC3BA,EAAK,IAAMA,EAAK,IAAMA,EAAK,IAC3BA,EAAK,IAAMA,EAAK,IAAMA,EAAK,GAAK,OAAO,EAC5C,IAAK,IAAIK,EAAI,EAAGA,EAAI,EAAGA,IAAKU,GAAWf,EAAKK,GAAKL,GAAMK,EAAI,GAAK,GAChE,OAAOU,EAAU,GAGRC,EAAmB,SAAC1B,EAAUC,GAAsC,IAAvB0B,EAAsB,wDAC5E,GAAyB,MAArB5B,EAAOC,EAAKC,GAAc,MAAO,GACrC,GAAIuB,EAASxB,EAAKC,GAAM,MAAO,CAACA,GAChC,IAAM2B,EAAkB,GAClBC,EAAoB,GACpBC,EAAoC,GAE1C,IADAD,EAAME,KAAK9B,GACJ4B,EAAMT,QAAQ,CACjB,IAAIb,EAASsB,EAAMG,MACnB,IAAIF,EAAQvB,EAAO0B,YAAnB,CACAH,EAAQvB,EAAO0B,aAAc,EAC7BL,EAAIG,KAAKxB,GACT,IAAM2B,EAAWvD,EAAIiB,KAAKW,GAAQS,QAAO,SAAAnB,GAAC,OAAuB,MAAnBE,EAAOC,EAAKH,MACpDsC,EAAeD,EAASlB,QAAO,SAAAnB,GAAC,OAAI2B,EAASxB,EAAKH,MACpDsC,EAAaf,OACTO,GAAWQ,EAAaC,SAAQ,SAAAvC,GAAC,OAAI+B,EAAIG,KAAKlC,MAGtDqC,EAASE,SAAQ,SAAAvC,GAAC,OAAIgC,EAAME,KAAKlC,OAErC,OAAO+B,GAGES,EAAa,SAACrC,EAAYC,GACnC,GAAyB,MAArBF,EAAOC,EAAKC,GAAc,OAAO,EACrC,IACIS,EADO/B,EAAIiB,KAAKK,GACJU,KAAI,SAAAd,GAAC,OAAIE,EAAOC,EAAKH,MAAIc,KAAI,SAAAtB,GAAC,OAAU,MAANA,EAAY,EAAI,KAElE,GADYqB,EAAKjB,QAAO,SAACC,EAAMC,GAAP,OAAgBD,EAAOC,IAAM,IAC1C,EAAG,OAAO,EAErB,IADA,IAAI8B,EAAU,EACLV,EAAI,EAAGA,EAAI,EAAGA,IAAKU,GAAWf,EAAKK,GAAKL,GAAMK,EAAI,GAAK,GAChE,OAAOU,GAAW,GAGTa,EAAa,SAACC,EAAatC,GACpC,IAAMuC,EAAU,SAAC3C,GAAD,OAAiB0C,EAAKvB,QAAO,SAAAhB,GAAG,OAAuB,MAAnBD,EAAOC,EAAKH,MAAYuB,OAAS,GACrF,GAAIoB,EAAQvC,GAAM,MAAO,GACzB,IAAM2B,EAAkB,GAClBC,EAAoB,GACpBC,EAAoC,GAE1C,IADAD,EAAME,KAAK9B,GACJ4B,EAAMT,QAAQ,CACjB,IAAIb,EAASsB,EAAMG,MACnB,IAAIF,EAAQvB,EAAO0B,YAKnB,GAJAH,EAAQvB,EAAO0B,aAAc,EAC7BL,EAAIG,KAAKxB,GACW5B,EAAImB,UAAUS,GAAQS,QAAO,SAAAnB,GAAC,OAAK2C,EAAQ3C,MACnDmB,QAAO,SAAAnB,GAAC,OAAKiC,EAAQjC,EAAEoC,eAAaG,SAAQ,SAAAvC,GAAC,OAAIgC,EAAME,KAAKlC,MACpE+B,EAAIR,OAAS,IAAM,MAE3B,OAAOQ,GAGEa,EAAS,SAACzC,GAAD,OAAc0C,GAAGD,OAAO,SAAUzC,IAa3C2C,EAAiB,SAACjE,EAAckE,GAGzC,GAFArE,EAAMsE,OAAOnE,GAETkE,EAAOE,SAAU,CACjB,IAAMC,EAAY,IAAIL,GAAGM,IAAIC,MAAMzE,EAAQ2B,KAAM3B,EAAQ0B,KAAM1B,EAAQ0E,QACnEN,EAAOO,eACPT,GAAGxD,IAAIV,EAASuE,EAAWA,GAE3BL,GAAGU,UAAU5E,EAASuE,EAAW,IAAK,IAAKL,GAAGW,eAElDX,GAAGY,SAASP,EAAWA,EAAWL,GAAGa,iBACrCb,GAAGc,YAAY9E,EAASkE,EAAOa,SAAUV,EAAWH,EAAOc,WAAY,EAAKhF,GAC5EqE,EAAUY,SAGd,IAAMC,EAAe,IAAIlB,GAAGM,IAC5BN,GAAGU,UAAU3E,EAAUmF,EAAc,IAAK,IAAKlB,GAAGW,eAClD,IAAMQ,EAAa,IAAInB,GAAGM,IAC1BN,GAAGY,SAASM,EAAcC,EAAYnB,GAAGa,iBACzC,IAAMO,EAAgB,IAAIpB,GAAGM,IAAIa,EAAW1D,KAAM0D,EAAW3D,KAAM2D,EAAWX,OAAQN,EAAOmB,WAAWpD,KAAI,SAAAqD,GAAC,OAAI,IAAMA,MACvHtB,GAAGuB,SAASJ,EAAYC,EAAeD,EAAYD,GACnDlB,GAAGxD,IAAIR,EAASmF,EAAYnF,GAC5BgE,GAAGuB,SAASvF,EAASoF,EAAepF,EAASkF,GAE7CA,EAAaD,SACbE,EAAWF,SACXG,EAAcH,UAGLO,EAAa,SAAClE,GACvB0C,GAAGU,UAAUpD,EAAKA,EAAK,IAAK,IAAK0C,GAAGW,eACpC,IAAK,IAAItC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAIC,EAAS0B,GAAGM,IAAImB,KAAKpD,EAAGA,EAAG2B,GAAG0B,OAC9BC,EAAU,IAAI3B,GAAGM,IACrBN,GAAG4B,OAAOtE,EAAKqE,EAASrD,EAAQ,IAAI0B,GAAG6B,OAAO,GAAI,GAAI,EAAG7B,GAAG8B,gBAAiB9B,GAAG+B,gCAChF/B,GAAGc,YAAYxD,EAAK,GAAKqE,EAAS,GAAK,EAAKrE,GAC5CgB,EAAO2C,SACPU,EAAQV,WAcHe,EAAS,WAClB,OAAO,eAAKpG,IAGHqG,EAAS,SAACC,GACfA,EAAIC,GAAK,GAAKD,EAAIE,GAAK,GAAKF,EAAIC,EAAID,EAAIG,MAAQ5G,EAAM+B,MAAQ0E,EAAIE,EAAIF,EAAII,OAAS7G,EAAMgC,OACrF7B,IACAI,EAAQiF,SACRpF,EAAMoF,SACNnF,EAAQmF,SACRlF,EAASkF,UAEbjF,EAAU,IAAIgE,GAAGM,IAAI4B,EAAII,OAAQJ,EAAIG,MAAO5G,EAAM+E,QAClD3E,EAAQJ,EAAMyG,IAAIA,GAClBpG,EAAUJ,EAAQwG,IAAIA,GACtBnG,EAAWJ,EAASuG,IAAIA,GACxBtG,EAAUsG,ICrMLK,EAAkB,CAC3BnC,UAAU,EACVK,gBAAgB,EAChBY,WAAY,CAAC,IAAK,IAAK,EAAG,KAC1BN,SAAU,EACVC,WAAY,IAGHwB,EAAgB,IAAIC,IAA+BF,GACnDG,EAAY,IAAIC,IAEhBC,EAAY,IAAID,IAChBE,EAAa,IAAIF,IACjBG,EAAc,IAAIH,IAClBI,EAAgB,IAAIJ,IAE3BK,EAAuB,CACzBC,ODsGkB,SAAC3F,EAAUC,EAAe2F,GACxC3F,EAAI,IAAM,GAAKA,EAAI,IAAM,GAAKA,EAAI,GAAKD,EAAIE,MAAQD,EAAI,GAAKD,EAAIG,MAChEH,EAAII,SAASH,EAAI,GAAIA,EAAI,IAAI4F,IAAID,ICvGrCE,MD0GiB,SAAC9F,EAAU+F,GAC5B,IAAMC,EAAU,IAAItD,GAAGM,IAAIhD,EAAIG,KAAMH,EAAIE,KAAMF,EAAIkD,OAAQ,CAAC,EAAG,EAAG,EAAG6C,IACrErD,GAAGuB,SAASjE,EAAKgG,EAAShG,GAC1BgG,EAAQrC,WC1GZuB,EACKe,KACGjF,aAAO,kBAAMtC,MAEhBwH,WAAU,WACPvD,EAAejE,EAASwG,EAAciB,OACtC1D,EAAO/D,MAGf0G,EACKa,KACGG,YAAIzB,IAEPuB,WAAU,WACPhC,EAAW1F,GACXmE,EAAejE,EAASwG,EAAciB,OACtC1D,EAAO/D,MAGf4G,EACKW,KACGG,aDiIgB,SAACC,GACrBlI,EAAQuE,GAAG4D,OAAOD,GAClBjI,EAAU,IAAIsE,GAAGM,IACjBN,GAAGY,SAASnF,EAAOC,EAASsE,GAAG6D,eAAgB,GAC/C7D,GAAG8D,MAAMpI,EAASA,EAAS,GAAI,IAAK,GAAG,GACvCC,EAAW,IAAIqE,GAAGM,IAAIC,MAAM7E,EAAQ+B,KAAM/B,EAAQ8B,KAAM9B,EAAQ8E,QAChEyB,EAAO,CAAEE,EAAG,IAAKC,EAAG,IAAKC,MAAO,IAAKC,OAAQ,MAC7Cd,EAAW1F,OCtIV0H,WACG,kBAAMT,EAAcgB,MAAK,SAACzG,EAAK0G,GAAN,OAAeA,EAAKZ,MAAM9F,EAAK,UAGhEuF,EACKU,KACGjF,aAAO,kBAAMxC,KACb4H,aAAI,SAAAO,GAAM,OAAIA,EAAOnI,EAASkH,OAEjCQ,WAAU,WACPhC,EAAW1F,GACXmE,EAAejE,EAASwG,EAAciB,OACtC1D,EAAO/D,MAGf8G,EACKS,KACGjF,aAAO,kBAAMvC,KACb2H,aAAI,SAAAO,GAAM,OAAIA,EAAOlI,EAAUiH,OAElCQ,WAAU,WACPvD,EAAejE,EAASwG,EAAciB,OACtC1D,EAAO/D,MAGf+G,EACKQ,KACGjF,aAAO,kBAAMtC,KACb0H,aAAI,kBAAMzD,EAAejE,EAASwG,EAAciB,UAChDC,aAAI,SAAAO,GAAM,OAAIA,EAAOjI,EAASgH,OAEjCQ,WAAU,WACPzD,EAAO/D,M,UClETkI,EAAmB,CACrBC,EAAG,CALS,EACD,EACE,GAIbC,EAAG,CANS,EAEC,GAKbC,EAAG,CANQ,EACE,GAMbC,EAAG,CANU,GAObC,EAAG,CAPU,GAQbC,EAAG,CAXU,IAcXC,EAAe,CACjBN,EAAG,CAAC,EAAG,EAAG,EAAG,GACbC,EAAG,CAAC,EAAG,IAAK,IAAK,KACjBC,EAAG,CAAC,IAAK,EAAG,IAAK,KACjBC,EAAG,CAAC,IAAK,EAAG,EAAG,MAOfI,EAAsB,GAEpBC,EAAY,SAACC,EAA2BC,GAC1C,IAAMC,EAAOF,EAAOG,wBACpB,MAAO,EAAEF,EAAEG,QAAUF,EAAKG,MAAQH,EAAKzC,OAAQwC,EAAEK,QAAUJ,EAAKK,KAAOL,EAAKxC,SAG1E8C,EAAY,SAAClD,EAAUmD,GACzB,IAAMnG,EAAMmG,EAAOpH,KAAI,SAACd,EAAGkB,GAAJ,OAAUhC,KAAKiJ,MAAMnI,EAAI,CAAC+E,EAAIG,MAAOH,EAAII,QAAQjE,OACxE,MAAO,CAACa,EAAI,GAAIA,EAAI,KAGT,SAASqG,IAAO,IAAD,EACMC,oBAAS,GADf,mBACnBC,EADmB,KACRC,EADQ,OAEUF,mBA/CV,GA6CA,mBAEnBG,EAFmB,KAEPC,EAFO,OAGUJ,mBAvCxB,GAoCc,mBAGnBK,EAHmB,KAGPC,EAHO,OAIUN,oBAAS,GAJnB,mBAInBO,EAJmB,KAINC,EAJM,OAKYR,mBAAS,EAAE,GAAI,IAL3B,mBAKnBS,EALmB,KAKNC,EALM,KAMpBC,EAAWC,iBAAyB,MAEpCC,EAAWC,uBAAY,SAAC/I,GAAoC,IAC1DgJ,EADqCC,EAAoB,wDAE7D,OAAQX,GACJ,KAhDK,EAiDDU,EAAU,GACV,MACJ,KAhDK,EAiDDA,EAAU,CAAChJ,GACX,MACJ,KArDI,EAsDAgJ,EAAUvH,EAAiBlD,EAAS6B,EAAQ7B,EAASyB,IACrD,MACJ,KAvDG,EAwDCgJ,EAAU,CAAC5I,EAAQ7B,EAASyB,GAAK,IAAOe,QAAO,SAAAnB,GAAC,OAAIE,EAAOvB,EAASqB,MAE5E,GA/DwB,IA+DpBwI,EAA4B,CAC5B,IAAKI,EAAa,OAClB,IAAM7D,EAAMF,IACZU,EAAUqB,KAAK,CACX5B,EAAGD,EAAIC,EAAI8D,EAAY,GAAK1I,EAAI,GAChC6E,EAAGF,EAAIE,EAAI6D,EAAY,GAAK1I,EAAI,GAChC8E,MAAO,IACPC,OAAQ,MAEZoC,EAAKrF,KAAK,CAAEoH,OAxEQ,EAwEaF,QAAS,CAACN,EAAa1I,UACrD,GA9Ee,IA8EXoI,IAA8BI,IAAeS,EACpDzD,EAAcgB,MAAK,SAACzG,EAAK0G,GAAN,OAAeuC,EAAQ7G,SAAQ,SAAAvC,GAAC,OAC/C6G,EAAKf,OAAO3F,EAAKH,EAAGsH,EAAaoB,cAElC,CACH,IAAKU,EAAQ7H,OAAQ,OACrB,OAAQiH,GACJ,KApFc,EAqFVY,EAAUA,EAAQjI,QAAO,SAAAnB,GAAC,OAAIE,EAAOvB,EAASqB,MAC9C0F,EAAWkB,MAAK,SAACzG,EAAK0G,GAAN,OAAeuC,EAAQ7G,SAAQ,SAAAvC,GAAC,OAAI6G,EAAKf,OAAO3F,EAAKH,EAAG,CAAC,UACzE,MACJ,KAvFc,EAwFV0F,EAAWkB,MAAK,SAACzG,EAAK0G,GAAN,OAAeuC,EAAQ7G,SAAQ,SAAAvC,GAAC,OAAI6G,EAAKf,OAAO3F,EAAKH,EAAG,CAAC,YACzE,MACJ,KAzFgB,EA4FZ,IAFA,IAAMA,EAAIoJ,EAAQjH,MACZoH,EAAQ,GACLrI,EAAIlB,EAAE,GAAKuJ,EAAOrI,EAAIlB,EAAE,GAAKuJ,EAAOrI,IACzC,IAAK,IAAIsI,EAAIxJ,EAAE,GAAKuJ,EAAOC,EAAIxJ,EAAE,GAAKuJ,EAAOC,IACzCJ,EAAQlH,KAAK,CAAChB,EAAGsI,IACzBJ,EAAUA,EAAQjI,QAAO,SAAAnB,GAAC,OAAIwC,EAAW7D,EAASqB,MAClD0F,EAAWkB,MAAK,SAACzG,EAAK0G,GAAN,OAAeuC,EAAQ7G,SAAQ,SAAAvC,GAAC,OAAI6G,EAAKf,OAAO3F,EAAKH,EAAG,CAAC,YACzE,MACJ,KAjGe,EAkGXoJ,EAAU3G,EAAW,CAAC9D,EAASC,GAAWwK,EAAQ,IAClDzD,EAAYiB,MAAK,SAACzG,EAAK0G,GAAN,OAAeuC,EAAQ7G,SAAQ,SAAAvC,GAAC,OAAI6G,EAAKf,OAAO3F,EAAKH,EAAG,CAAC,YAElF,IAAKoJ,EAAQ7H,OAAQ,OACrBgG,EAAKrF,KAAK,CAAEoH,OAAQd,EAAYY,QAASA,OAE9C,CAACZ,EAAYE,EAAYE,EAAaE,IAEnCW,EAAON,uBAAY,SAACO,GACtB,OAAQA,EAAEJ,QACN,KA/GkB,EAgHd5D,EAAWkB,MAAK,SAACzG,EAAK0G,GAAN,OAAe6C,EAAEN,QAAQ7G,SAAQ,SAAAvC,GAAC,OAAI6G,EAAKf,OAAO3F,EAAKH,EAAG,CAAC,YAC3E,MACJ,KAjHkB,EAoHlB,KAnHoB,EAoHhB0F,EAAWkB,MAAK,SAACzG,EAAK0G,GAAN,OAAe6C,EAAEN,QAAQ7G,SAAQ,SAAAvC,GAAC,OAAI6G,EAAKf,OAAO3F,EAAKH,EAAG,CAAC,UAC3E,MACJ,KArHmB,EAsHf2F,EAAYiB,MAAK,SAACzG,EAAK0G,GAAN,OAAe6C,EAAEN,QAAQ7G,SAAQ,SAAAvC,GAAC,OAAI6G,EAAKf,OAAO3F,EAAKH,EAAG,CAAC,UAC5E,MACJ,KAvHoB,EAwHhB,IAAM+E,EAAMF,IACZU,EAAUqB,KAAK,CACX5B,EAAGD,EAAIC,EAAI0E,EAAEN,QAAQ,GAAG,GAAKM,EAAEN,QAAQ,GAAG,GAC1CnE,EAAGF,EAAIE,EAAIyE,EAAEN,QAAQ,GAAG,GAAKM,EAAEN,QAAQ,GAAG,GAC1ClE,MAAO,IACPC,OAAQ,SAGrB,IAEGwE,EAAcR,uBAAY,SAACzB,GAC7BjC,EAAUmB,KAAKc,EAAEkC,iBAClB,IAEGC,EAAqBV,uBAAY,SAACzB,GACpC9B,EAAcgB,MAAK,SAACzG,EAAK0G,GAChByB,GAAWzB,EAAKZ,MAAM9F,EAAK,SAErC,CAACmI,IAEEwB,EAAqBX,uBAAY,SAACzB,GACpC9B,EAAcgB,MAAK,SAACzG,EAAK0G,GAChByB,GAAWzB,EAAKZ,MAAM9F,EAAK,SAErC,CAACmI,IAEEyB,EAAoBZ,uBAAY,SAACzB,GACnC,GAAKY,GACAzD,IAAL,CACA,IAAMzE,EAAM6H,EAAUpD,IAAU2C,EAAUE,EAAEkC,cAAelC,IACvDtH,EAAIgC,aAAe0G,EAAY1G,aACnC8G,EAAS9I,GACT2I,EAAe3I,OAChB,CAACkI,EAAWQ,EAAaI,IAEtBc,EAAoBb,uBAAY,SAACzB,GACnC,GAAKY,IACLO,GAAa,GAlKS,IAmKlBL,GACC3D,KAAL,CACA,IAAMzE,EAAM6H,EAAUpD,IAAU2C,EAAUE,EAAEkC,cAAelC,IAC3DwB,EAAS9I,GAAK,MACf,CAACkI,EAAWE,EAAYU,IAErBe,GAAkBd,uBAAY,SAACzB,GACjCmB,GAAa,KACd,IAEGqB,GAAWf,uBAAY,SAACgB,EAA2BC,GACrD,GAAI1B,IAAeyB,EAAe,CAC9B,KAAOpD,EAAiBqD,GAAe3I,QAAQ0I,GAAiB,GAC5DA,GAAiBA,EAAgB,GAAK,EAC1CxB,EAAcwB,GAElB,GAAI3B,IAAe4B,EAEf,OADA3B,EAAc2B,GACNA,GACJ,KArLc,EAsLVzB,EA9KJ,GA+KItD,EAAcuB,KAAd,eAAwBxB,EAAxB,CAAyC9B,gBAAgB,EAAMM,SAAU,MACzE,MACJ,KAxLc,EAyLV+E,EAjLL,GAkLKtD,EAAcuB,KAAd,eAAwBxB,EAAxB,CAAyCxB,SAAU,GAAKC,WAAY,MACpE,MACJ,KA3LgB,EA4LZ8E,EApLH,GAqLGtD,EAAcuB,KAAd,eAAwBxB,EAAxB,CAAyCxB,SAAU,GAAKC,WAAY,MACpE,MACJ,KA9Le,EA+LX8E,EAxLH,GAyLGtD,EAAcuB,KAAd,eAAwBxB,EAAxB,CAAyCxB,SAAU,MACnD,MACJ,KAjMgB,EAkMZ+E,EA/LH,GAgMGtD,EAAcuB,KAAKxB,GACnB,MACJ,QACIuD,EAlMJ,GAmMItD,EAAcuB,KAAKxB,MAGhC,CAACsD,EAAYF,IAGV6B,GAAmBlB,uBAAY,SAACzB,GAClCqB,EAAe,EAAE,GAAI,IACrB,IAAIoB,EAA4BzB,EAAY0B,EAA4B5B,EACxE,OAAQd,EAAE4C,KACN,IAAK,IACDH,GAAiBzB,EAAa,GAAK,EACnC,MACJ,IAAK,IACGnB,EAAKhG,QAAQkI,EAAKlC,EAAKpF,OAC3B,MACJ,IAAK,IACDiI,EA5Nc,EA6Nd,MACJ,IAAK,IACDA,EA9Nc,EA+Nd,MACJ,IAAK,IACDA,EAhOgB,EAiOhB,MACJ,IAAK,IACDA,EAlOe,EAmOf,MACJ,IAAK,IACDA,EApOgB,EAqOhB,MACJ,QACIA,EA5Oc,EA8OtBF,GAASC,EAAeC,KACzB,CAAC5B,EAAYE,EAAYe,EAAMS,KAE5BK,GAAgBpB,uBAAY,WAC9BZ,GAAW,KACZ,IAEGiC,GAAerB,uBAAY,WAC7BZ,GAAW,GACX3C,EAAcgB,MAAK,SAACzG,EAAK0G,GAAN,OAAeA,EAAKZ,MAAM9F,EAAK,SACnD,IAEH,OACI,yBAAKsK,UAAU,OACX,yBAAKA,UAAU,SACX,yBAAKC,GAAG,WAAWC,IAAK,eAAgBC,IAAK5B,EAAU6B,OAAQlB,EAAamB,MAAO,CAAEjM,QAAS,UAC9F,2BAAOwE,KAAK,OAAOqH,GAAG,YAAYK,KAAK,OAAOC,SAAU,SAACtD,GACrDsB,EAASiC,QAASzE,IAAM0E,IAAIC,gBAAgBzD,EAAE0D,OAAOC,MAAO,QAGpE,yBAAKZ,UAAU,SACX,0CACA,kBAAC,IAAMa,MAAP,CAAahF,MAAOkC,EAAYwC,SAAU,SAACtD,GAAD,OAAOwC,GAASxB,EAAYhB,EAAE0D,OAAO9E,QAAQiF,UAAW1G,KAC9F,kBAAC,IAAM2G,OAAP,CAAclF,MArQJ,GAqQV,aACA,kBAAC,IAAMkF,OAAP,CAAclF,MArQJ,GAqQV,iBACA,kBAAC,IAAMkF,OAAP,CAAclF,MArQJ,GAqQV,iBACA,kBAAC,IAAMkF,OAAP,CAAclF,MArQF,GAqQZ,mBACA,kBAAC,IAAMkF,OAAP,CAAclF,MArQH,GAqQX,kBACA,kBAAC,IAAMkF,OAAP,CAAclF,MArQF,GAqQZ,qBAGR,yBAAKmE,UAAU,SACX,8CACA,kBAAC,IAAMa,MAAP,CAAahF,MAAOoC,EAAYsC,SAAU,SAACtD,GAAD,OAAOwC,GAASxC,EAAE0D,OAAO9E,MAAOkC,IAAa+C,UAAW1G,KAC9F,kBAAC,IAAM2G,OAAP,CAAclF,MAvQlB,EAuQkCiF,SAAUxE,EAAiByB,GAAY/G,QAvQzE,GAuQ4F,GAAxF,gBACA,kBAAC,IAAM+J,OAAP,CAAclF,MAvQnB,EAuQkCiF,SAAUxE,EAAiByB,GAAY/G,QAvQzE,GAuQ2F,GAAtF,kBACA,kBAAC,IAAM+J,OAAP,CAAclF,MAvQjB,EAuQkCiF,SAAUxE,EAAiByB,GAAY/G,QAvQzE,GAuQ6F,GAA1F,aAEJ,kBAAC,IAAD,CAAQgJ,UAAU,OAAOpH,KAAK,SAASoI,OAAK,EAACC,QAAS,WAAYnE,EAAKhG,QAAQkI,EAAKlC,EAAKpF,QAAWoJ,UAAW1G,KAA/G,aAEJ,yBAAK4F,UAAU,UACX,4BACIC,GAAG,SACHD,UApRY,IAoRDjC,EAA6B,SAAW,GACnDmD,aAAc9B,EACd+B,aAAc9B,EACd+B,YAAa9B,EACb+B,YAAa9B,EACb+B,UAAW9B,GACX+B,WAAY3B,GACZ4B,QAAS1B,GACT2B,OAAQ1B,GACR2B,SAAU,QC/RVC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a","file":"static/js/main.8d356ffa.chunk.js","sourcesContent":["declare const cv: any\r\n\r\nvar bgMat: any\r\nvar edgeMat: any\r\nvar labelMat: any\r\n\r\nvar roiRect: any\r\n\r\nvar bgRoi: any\r\nexport var edgeRoi: any\r\nexport var labelRoi: any\r\nexport var display: any\r\n\r\nexport type ComposeConfig = {\r\n    showEdge: boolean,\r\n    showEdgeValley: boolean,\r\n    labelColor: number[],\r\n    bgWeight: number,\r\n    edgeWeight: number,\r\n}\r\n\r\nexport const Pos = {\r\n    dist: (v1: number[], v2: number[]) => Math.sqrt(Math.pow(v1[0] - v2[0], 2) + Math.pow(v1[1] - v2[1], 2)),\r\n    add: (v1: number[], v2: number[]) => [v1[0] + v2[0], v1[1] + v2[1]],\r\n    sub: (v1: number[], v2: number[]) => [v1[0] - v2[0], v1[1] - v2[1]],\r\n    mul: (v: number[], m: number) => [v[0] * m, v[1] * m],\r\n    sum: (vecs: number[][]) => vecs.reduce((prev, curr) => Pos.add(prev, curr), [0, 0]),\r\n    nbrs: (p: number[]) => [\r\n        [p[0] - 1, p[1] - 1], [p[0], p[1] - 1], [p[0] + 1, p[1] - 1], [p[0] + 1, p[1]],\r\n        [p[0] + 1, p[1] + 1], [p[0], p[1] + 1], [p[0] - 1, p[1] + 1], [p[0] - 1, p[1]]\r\n    ],\r\n    closeNbrs: (p: number[]) => [\r\n        [p[0], p[1] - 1], [p[0] + 1, p[1]],\r\n        [p[0], p[1] + 1], [p[0] - 1, p[1]]\r\n    ],\r\n}\r\n\r\nexport const getVal = (mat: any, pos: number[]) => {\r\n    if (pos[0] >= 0 && pos[1] >= 0 && pos[0] < mat.cols && pos[1] < mat.rows)\r\n        return mat.ucharPtr(pos[0], pos[1])[0] as number\r\n    return 0\r\n}\r\n\r\nexport const fallPos = (mat: any, pos: number[], earlyStop = false) => {\r\n    let [curPos, curVal] = [pos, getVal(mat, pos)]\r\n    if (curVal === 0) return curPos\r\n    for (let r = 0; r < 20; r++) {\r\n        let nbrs = Pos.nbrs(curPos)\r\n        let vals = nbrs.map(pos => getVal(mat, pos))\r\n        const maxNbrVal = Math.max(...vals)\r\n        if (maxNbrVal === curVal) break\r\n        const maxNbrs = vals.map((v, i) => v === maxNbrVal ? i : -1).filter(i => i > -1)\r\n        if (earlyStop && maxNbrVal === 255) break\r\n        vals = vals.filter((_, i) => maxNbrs.includes(i))\r\n        nbrs = nbrs.filter((_, i) => maxNbrs.includes(i))\r\n        const direction = Pos.sub(Pos.mul(Pos.sum(nbrs), 1 / maxNbrs.length), curPos)\r\n        const dists = nbrs.map(pos => Pos.dist(pos, direction))\r\n        curPos = nbrs[dists.indexOf(Math.min(...dists))]\r\n        curVal = maxNbrVal\r\n        if (curVal === 255) break\r\n    }\r\n    return curPos\r\n}\r\n\r\nconst isBranch = (mat: any, pos: number[]) => {\r\n    let nbrs = Pos.nbrs(pos)\r\n    let vals = nbrs.map(p => getVal(mat, p)).map(v => v === 255 ? 1 : 0)\r\n    let changes = 0\r\n    if ((vals[7] && vals[0] && vals[1]) ||\r\n        (vals[1] && vals[2] && vals[3]) ||\r\n        (vals[3] && vals[4] && vals[5]) ||\r\n        (vals[5] && vals[6] && vals[7])) return true\r\n    for (let i = 0; i < 8; i++) changes += vals[i] ^ vals[(i + 1) % 8]\r\n    return changes > 4\r\n}\r\n\r\nexport const selectTillBranch = (mat: any, pos: number[], inclusive = false) => {\r\n    if (getVal(mat, pos) !== 255) return []\r\n    if (isBranch(mat, pos)) return [pos]\r\n    const res: number[][] = []\r\n    const stack: number[][] = []\r\n    const visited: { [p: string]: boolean } = {}\r\n    stack.push(pos)\r\n    while (stack.length) {\r\n        let curPos = stack.pop()!\r\n        if (visited[curPos.toString()]) continue\r\n        visited[curPos.toString()] = true\r\n        res.push(curPos)\r\n        const edgeNbrs = Pos.nbrs(curPos).filter(p => getVal(mat, p) === 255)\r\n        const branchedNbrs = edgeNbrs.filter(p => isBranch(mat, p))\r\n        if (branchedNbrs.length) {\r\n            if (inclusive) branchedNbrs.forEach(p => res.push(p))\r\n            continue\r\n        }\r\n        edgeNbrs.forEach(p => stack.push(p))\r\n    }\r\n    return res\r\n}\r\n\r\nexport const needRepair = (mat: any[], pos: number[]) => {\r\n    if (getVal(mat, pos) === 255) return false\r\n    let nbrs = Pos.nbrs(pos)\r\n    let vals = nbrs.map(p => getVal(mat, p)).map(v => v === 255 ? 1 : 0)\r\n    const sum = vals.reduce((prev, curr) => prev + curr, 0 as number)\r\n    if (sum >= 7) return true\r\n    let changes = 0\r\n    for (let i = 0; i < 8; i++) changes += vals[i] ^ vals[(i + 1) % 8]\r\n    return changes >= 4\r\n}\r\n\r\nexport const fillSelect = (mats: any[], pos: number[]) => {\r\n    const hitWall = (p: number[]) => mats.filter(mat => getVal(mat, p) === 255).length > 0\r\n    if (hitWall(pos)) return []\r\n    const res: number[][] = []\r\n    const stack: number[][] = []\r\n    const visited: { [p: string]: boolean } = {}\r\n    stack.push(pos)\r\n    while (stack.length) {\r\n        let curPos = stack.pop()!\r\n        if (visited[curPos.toString()]) continue\r\n        visited[curPos.toString()] = true\r\n        res.push(curPos)\r\n        const nonEdgeNbrs = Pos.closeNbrs(curPos).filter(p => !hitWall(p))\r\n        nonEdgeNbrs.filter(p => !visited[p.toString()]).forEach(p => stack.push(p))\r\n        if (res.length > 1000) break\r\n    }\r\n    return res\r\n}\r\n\r\nexport const imshow = (mat: any) => cv.imshow('canvas', mat)\r\n\r\nexport const setVal = (mat: any, pos: number[], val: number[]) => {\r\n    if (pos[0] >= 0 && pos[1] >= 0 && pos[0] < mat.cols && pos[1] < mat.rows)\r\n        mat.ucharPtr(pos[0], pos[1]).set(val)\r\n}\r\n\r\nexport const dimBy = (mat: any, amount: number) => {\r\n    const dimMask = new cv.Mat(mat.rows, mat.cols, mat.type(), [0, 0, 0, amount])\r\n    cv.subtract(mat, dimMask, mat)\r\n    dimMask.delete()\r\n}\r\n\r\nexport const composeDisplay = (display: any, config: ComposeConfig) => {\r\n    bgRoi.copyTo(display)\r\n\r\n    if (config.showEdge) {\r\n        const edgeCvted = new cv.Mat.zeros(edgeRoi.rows, edgeRoi.cols, edgeRoi.type())\r\n        if (config.showEdgeValley) {\r\n            cv.add(edgeRoi, edgeCvted, edgeCvted)\r\n        } else {\r\n            cv.threshold(edgeRoi, edgeCvted, 254, 255, cv.THRESH_BINARY)\r\n        }\r\n        cv.cvtColor(edgeCvted, edgeCvted, cv.COLOR_GRAY2RGBA)\r\n        cv.addWeighted(display, config.bgWeight, edgeCvted, config.edgeWeight, 0.0, display)\r\n        edgeCvted.delete()\r\n    }\r\n\r\n    const labelThresed = new cv.Mat()\r\n    cv.threshold(labelRoi, labelThresed, 254, 255, cv.THRESH_BINARY)\r\n    const labelCvted = new cv.Mat()\r\n    cv.cvtColor(labelThresed, labelCvted, cv.COLOR_GRAY2RGBA)\r\n    const labelColorInv = new cv.Mat(labelCvted.rows, labelCvted.cols, labelCvted.type(), config.labelColor.map(c => 255 - c))\r\n    cv.subtract(labelCvted, labelColorInv, labelCvted, labelThresed)\r\n    cv.add(display, labelCvted, display)\r\n    cv.subtract(display, labelColorInv, display, labelThresed)\r\n\r\n    labelThresed.delete()\r\n    labelCvted.delete()\r\n    labelColorInv.delete()\r\n}\r\n\r\nexport const growValley = (mat: any) => {\r\n    cv.threshold(mat, mat, 254, 255, cv.THRESH_BINARY);\r\n    for (let i = 2; i < 6; i++) {\r\n        let filter = cv.Mat.ones(i, i, cv.CV_8U);\r\n        let dilated = new cv.Mat()\r\n        cv.dilate(mat, dilated, filter, new cv.Point(-1, -1), 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())\r\n        cv.addWeighted(mat, 0.8, dilated, 0.2, 0.0, mat);\r\n        filter.delete()\r\n        dilated.delete()\r\n    }\r\n}\r\n\r\nexport const initMats = (src: HTMLImageElement) => {\r\n    bgMat = cv.imread(src)\r\n    edgeMat = new cv.Mat()\r\n    cv.cvtColor(bgMat, edgeMat, cv.COLOR_RGB2GRAY, 0)\r\n    cv.Canny(edgeMat, edgeMat, 50, 100, 3, false)\r\n    labelMat = new cv.Mat.zeros(edgeMat.rows, edgeMat.cols, edgeMat.type())\r\n    setRoi({ x: 550, y: 450, width: 500, height: 500 })\r\n    growValley(edgeRoi)\r\n}\r\n\r\nexport const getRoi = () => {\r\n    return { ...roiRect }\r\n}\r\n\r\nexport const setRoi = (roi: any) => {\r\n    if (roi.x >= 0 && roi.y >= 0 && roi.x + roi.width < bgMat.cols && roi.y + roi.height < bgMat.rows) {\r\n        if (roiRect) {\r\n            display.delete()\r\n            bgRoi.delete()\r\n            edgeRoi.delete()\r\n            labelRoi.delete()\r\n        }\r\n        display = new cv.Mat(roi.height, roi.width, bgMat.type())\r\n        bgRoi = bgMat.roi(roi)\r\n        edgeRoi = edgeMat.roi(roi)\r\n        labelRoi = labelMat.roi(roi)\r\n        roiRect = roi\r\n    }\r\n}\r\n","import { Subject, BehaviorSubject } from 'rxjs'\r\nimport { tap, filter } from 'rxjs/operators'\r\n\r\nimport { edgeRoi, labelRoi, display, imshow, setVal, growValley, composeDisplay, dimBy, initMats, setRoi, ComposeConfig } from './model'\r\n\r\ntype MatUtil = {\r\n    setVal: (mat: any, pos: number[], val: number[]) => void\r\n    dimBy: (mat: any, amount: number) => void\r\n}\r\n\r\ntype MatUpdate = (mat: any, util: MatUtil) => void\r\n\r\nexport const DEFAULT_COMPOSE = {\r\n    showEdge: true,\r\n    showEdgeValley: false,\r\n    labelColor: [255, 255, 0, 255],\r\n    bgWeight: 1,\r\n    edgeWeight: 0.4,\r\n}\r\n\r\nexport const composeUpdate = new BehaviorSubject<ComposeConfig>(DEFAULT_COMPOSE)\r\nexport const roiUpdate = new Subject<any>()\r\n\r\nexport const srcUpdate = new Subject<HTMLImageElement>()\r\nexport const edgeUpdate = new Subject<MatUpdate>()\r\nexport const labelUpdate = new Subject<MatUpdate>()\r\nexport const displayUpdate = new Subject<MatUpdate>()\r\n\r\nconst MatUtilImpl: MatUtil = {\r\n    setVal: setVal,\r\n    dimBy: dimBy,\r\n}\r\n\r\ncomposeUpdate\r\n    .pipe(\r\n        filter(() => display),\r\n    )\r\n    .subscribe(() => {\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nroiUpdate\r\n    .pipe(\r\n        tap(setRoi)\r\n    )\r\n    .subscribe(() => {\r\n        growValley(edgeRoi)\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nsrcUpdate\r\n    .pipe(\r\n        tap(initMats)\r\n    )\r\n    .subscribe(\r\n        () => displayUpdate.next((mat, util) => util.dimBy(mat, 96))\r\n    )\r\n\r\nedgeUpdate\r\n    .pipe(\r\n        filter(() => edgeRoi),\r\n        tap(update => update(edgeRoi, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        growValley(edgeRoi)\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nlabelUpdate\r\n    .pipe(\r\n        filter(() => labelRoi),\r\n        tap(update => update(labelRoi, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\ndisplayUpdate\r\n    .pipe(\r\n        filter(() => display),\r\n        tap(() => composeDisplay(display, composeUpdate.value)),\r\n        tap(update => update(display, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        imshow(display)\r\n    })\r\n","import React, { useRef, SyntheticEvent, MouseEvent, KeyboardEvent, useState, useCallback } from 'react'\nimport { Radio, Button } from 'antd'\nimport 'antd/dist/antd.css'\n\nimport { srcUpdate, edgeUpdate, labelUpdate, displayUpdate, composeUpdate, DEFAULT_COMPOSE, roiUpdate } from './controller'\nimport { edgeRoi, labelRoi, getVal, fallPos, selectTillBranch, fillSelect, needRepair, getRoi } from './model'\nimport './App.css'\n\ntype ActionMode = 0 | 1 | 2 | 3 | 4 | 5\nconst NO_ACTION: ActionMode = 0\nconst WIPE_EDGE: ActionMode = 1\nconst DRAW_EDGE: ActionMode = 2\nconst REPAIR_EDGE: ActionMode = 3\nconst FILL_LABEL: ActionMode = 4\nconst MOVE_CANVAS: ActionMode = 5\n\ntype CursorMode = 0 | 1 | 2 | 3\nconst DISABLED = 0\nconst FALLING = 1\nconst ADHERE = 2\nconst FLOATING = 3\n\nconst ValidCursorModes = {\n    0: [FALLING, ADHERE, FLOATING],\n    1: [FALLING, FLOATING],\n    2: [ADHERE, FLOATING],\n    3: [FLOATING],\n    4: [FLOATING],\n    5: [DISABLED]\n}\n\nconst CursorColors = {\n    0: [0, 0, 0, 0],\n    1: [0, 255, 255, 255],\n    2: [255, 0, 255, 255],\n    3: [255, 0, 0, 255],\n}\n\ntype EditHistory = {\n    action: ActionMode,\n    targets: number[][]\n}\nvar hist: EditHistory[] = []\n\nconst getRelPos = (canvas: HTMLCanvasElement, e: React.MouseEvent<HTMLCanvasElement>) => {\n    const rect = canvas.getBoundingClientRect()\n    return [(e.clientX - rect.left) / rect.width, (e.clientY - rect.top) / rect.height]\n}\n\nconst getRoiPos = (roi: any, relPos: number[]) => {\n    const res = relPos.map((p, i) => Math.floor(p * [roi.width, roi.height][i]))\n    return [res[1], res[0]]\n}\n\nexport default function App() {\n    const [isFocused, setFocused] = useState(false)\n    const [actionMode, setActionMode] = useState<ActionMode>(NO_ACTION)\n    const [cursorMode, setCursorMode] = useState<CursorMode>(FALLING)\n    const [isMouseDown, setMouseDown] = useState(false)\n    const [movePrevPos, setMovePrevPos] = useState([-1, -1])\n    const imageSrc = useRef<HTMLImageElement>(null)\n\n    const doAction = useCallback((pos: number[], pressed = false) => {\n        let targets: number[][]\n        switch (cursorMode) {\n            case DISABLED:\n                targets = []\n                break\n            case FLOATING:\n                targets = [pos]\n                break\n            case FALLING:\n                targets = selectTillBranch(edgeRoi, fallPos(edgeRoi, pos))\n                break\n            case ADHERE:\n                targets = [fallPos(edgeRoi, pos, true)].filter(p => getVal(edgeRoi, p))\n        }\n        if (actionMode === MOVE_CANVAS) {\n            if (!isMouseDown) return\n            const roi = getRoi()\n            roiUpdate.next({\n                x: roi.x + movePrevPos[1] - pos[1],\n                y: roi.y + movePrevPos[0] - pos[0],\n                width: 500,\n                height: 500\n            })\n            hist.push({ action: MOVE_CANVAS, targets: [movePrevPos, pos] })\n        } else if (actionMode === NO_ACTION || !(isMouseDown || pressed)) {\n            displayUpdate.next((mat, util) => targets.forEach(p =>\n                util.setVal(mat, p, CursorColors[cursorMode]))\n            )\n        } else {\n            if (!targets.length) return\n            switch (actionMode) {\n                case WIPE_EDGE:\n                    targets = targets.filter(p => getVal(edgeRoi, p))\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [0])))\n                    break\n                case DRAW_EDGE:\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n                    break\n                case REPAIR_EDGE:\n                    const p = targets.pop()!\n                    const range = 20\n                    for (let i = p[0] - range; i < p[0] + range; i++)\n                        for (let j = p[1] - range; j < p[1] + range; j++)\n                            targets.push([i, j])\n                    targets = targets.filter(p => needRepair(edgeRoi, p))\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n                    break\n                case FILL_LABEL:\n                    targets = fillSelect([edgeRoi, labelRoi], targets[0])\n                    labelUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n            }\n            if (!targets.length) return\n            hist.push({ action: actionMode, targets: targets })\n        }\n    }, [actionMode, cursorMode, isMouseDown, movePrevPos])\n\n    const undo = useCallback((h: EditHistory) => {\n        switch (h.action) {\n            case WIPE_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [255])))\n                break\n            case DRAW_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case REPAIR_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case FILL_LABEL:\n                labelUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case MOVE_CANVAS:\n                const roi = getRoi()\n                roiUpdate.next({\n                    x: roi.x + h.targets[1][1] - h.targets[0][1],\n                    y: roi.y + h.targets[1][0] - h.targets[0][0],\n                    width: 500,\n                    height: 500\n                })\n        }\n    }, [])\n\n    const onImageLoad = useCallback((e: SyntheticEvent<HTMLImageElement, Event>) => {\n        srcUpdate.next(e.currentTarget)\n    }, [])\n\n    const onCanvasMouseEnter = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        displayUpdate.next((mat, util) => {\n            if (!isFocused) util.dimBy(mat, 48)\n        })\n    }, [isFocused])\n\n    const onCanvasMouseLeave = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        displayUpdate.next((mat, util) => {\n            if (!isFocused) util.dimBy(mat, 96)\n        })\n    }, [isFocused])\n\n    const onCanvasMouseMove = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!isFocused) return\n        if (!getRoi()) return\n        const pos = getRoiPos(getRoi(), getRelPos(e.currentTarget, e))\n        if (pos.toString() === movePrevPos.toString()) return\n        doAction(pos)\n        setMovePrevPos(pos)\n    }, [isFocused, movePrevPos, doAction])\n\n    const onCanvasMouseDown = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!isFocused) return\n        setMouseDown(true)\n        if (actionMode === NO_ACTION) return\n        if (!getRoi()) return\n        const pos = getRoiPos(getRoi(), getRelPos(e.currentTarget, e))\n        doAction(pos, true)\n    }, [isFocused, actionMode, doAction])\n\n    const onCanvasMouseUp = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        setMouseDown(false)\n    }, [])\n\n    const setModes = useCallback((newCursorMode: CursorMode, newActionMode: ActionMode) => {\n        if (cursorMode !== newCursorMode) {\n            while (ValidCursorModes[newActionMode].indexOf(newCursorMode) < 0)\n                newCursorMode = (newCursorMode + 1) % 3 as CursorMode\n            setCursorMode(newCursorMode)\n        }\n        if (actionMode !== newActionMode) {\n            setActionMode(newActionMode)\n            switch (newActionMode) {\n                case WIPE_EDGE:\n                    setCursorMode(FALLING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, showEdgeValley: true, bgWeight: 0.5 })\n                    break\n                case DRAW_EDGE:\n                    setCursorMode(ADHERE)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.8, edgeWeight: 0.8 })\n                    break\n                case REPAIR_EDGE:\n                    setCursorMode(FLOATING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.8, edgeWeight: 0.8 })\n                    break\n                case FILL_LABEL:\n                    setCursorMode(FLOATING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.6 })\n                    break\n                case MOVE_CANVAS:\n                    setCursorMode(DISABLED)\n                    composeUpdate.next(DEFAULT_COMPOSE)\n                    break\n                default:\n                    setCursorMode(FALLING)\n                    composeUpdate.next(DEFAULT_COMPOSE)\n            }\n        }\n    }, [cursorMode, actionMode])\n\n\n    const onCanvasKeyPress = useCallback((e: KeyboardEvent<HTMLCanvasElement>) => {\n        setMovePrevPos([-1, -1])\n        let newCursorMode: CursorMode = cursorMode, newActionMode: ActionMode = actionMode\n        switch (e.key) {\n            case \"f\":\n                newCursorMode = (cursorMode + 1) % 3 as CursorMode\n                break\n            case \"z\":\n                if (hist.length) undo(hist.pop()!)\n                break\n            case \"w\":\n                newActionMode = WIPE_EDGE\n                break\n            case \"e\":\n                newActionMode = DRAW_EDGE\n                break\n            case \"r\":\n                newActionMode = REPAIR_EDGE\n                break\n            case \"d\":\n                newActionMode = FILL_LABEL\n                break\n            case \"m\":\n                newActionMode = MOVE_CANVAS\n                break\n            default:\n                newActionMode = NO_ACTION\n        }\n        setModes(newCursorMode, newActionMode)\n    }, [actionMode, cursorMode, undo, setModes])\n\n    const onCanvasFocus = useCallback(() => {\n        setFocused(true)\n    }, [])\n\n    const onCanvasBlur = useCallback(() => {\n        setFocused(false)\n        displayUpdate.next((mat, util) => util.dimBy(mat, 96))\n    }, [])\n\n    return (\n        <div className=\"App\">\n            <div className=\"input\">\n                <img id=\"imageSrc\" alt={\"Canvas Input\"} ref={imageSrc} onLoad={onImageLoad} style={{ display: \"none\" }} />\n                <input type=\"file\" id=\"fileInput\" name=\"file\" onChange={(e) => {\n                    imageSrc.current!.src = URL.createObjectURL(e.target.files![0]);\n                }} />\n            </div>\n            <div className=\"radio\">\n                <span>Action: </span>\n                <Radio.Group value={actionMode} onChange={(e) => setModes(cursorMode, e.target.value)} disabled={!getRoi()}>\n                    <Radio.Button value={NO_ACTION}>No Action</Radio.Button>\n                    <Radio.Button value={WIPE_EDGE}>Wipe Edge (W)</Radio.Button>\n                    <Radio.Button value={DRAW_EDGE}>Draw Edge (E)</Radio.Button>\n                    <Radio.Button value={REPAIR_EDGE}>Repair Edge (R)</Radio.Button>\n                    <Radio.Button value={FILL_LABEL}>Fill Label (D)</Radio.Button>\n                    <Radio.Button value={MOVE_CANVAS}>Move Canvas (M)</Radio.Button>\n                </Radio.Group>\n            </div>\n            <div className=\"radio\">\n                <span>Cursor (F): </span>\n                <Radio.Group value={cursorMode} onChange={(e) => setModes(e.target.value, actionMode)} disabled={!getRoi()}>\n                    <Radio.Button value={FALLING} disabled={ValidCursorModes[actionMode].indexOf(FALLING) < 0}>Fall to Edge</Radio.Button>\n                    <Radio.Button value={ADHERE} disabled={ValidCursorModes[actionMode].indexOf(ADHERE) < 0}>Adhere to Edge</Radio.Button>\n                    <Radio.Button value={FLOATING} disabled={ValidCursorModes[actionMode].indexOf(FLOATING) < 0}>Floating</Radio.Button>\n                </Radio.Group>\n                <Button className=\"undo\" type=\"danger\" ghost onClick={() => { if (hist.length) undo(hist.pop()!) }} disabled={!getRoi()}>Undo (Z)</Button>\n            </div>\n            <div className=\"canvas\">\n                <canvas\n                    id=\"canvas\"\n                    className={actionMode === MOVE_CANVAS ? \"moving\" : \"\"}\n                    onMouseEnter={onCanvasMouseEnter}\n                    onMouseLeave={onCanvasMouseLeave}\n                    onMouseMove={onCanvasMouseMove}\n                    onMouseDown={onCanvasMouseDown}\n                    onMouseUp={onCanvasMouseUp}\n                    onKeyPress={onCanvasKeyPress}\n                    onFocus={onCanvasFocus}\n                    onBlur={onCanvasBlur}\n                    tabIndex={1000}\n                />\n            </div>\n        </div>\n    );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
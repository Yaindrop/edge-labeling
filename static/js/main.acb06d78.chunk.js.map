{"version":3,"sources":["model.ts","controller.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["bgMat","edgeMat","labelMat","roiRect","bgRoi","edgeRoi","labelRoi","display","Pos","dist","v1","v2","Math","sqrt","pow","add","sub","mul","v","m","sum","vecs","reduce","prev","curr","nbrs","p","closeNbrs","getVal","mat","pos","cols","rows","ucharPtr","fallPos","earlyStop","curPos","curVal","r","vals","map","maxNbrVal","max","maxNbrs","i","filter","_","includes","direction","length","dists","indexOf","min","isBranch","changes","selectTillBranch","inclusive","res","stack","visited","push","pop","toString","edgeNbrs","branchedNbrs","forEach","needRepair","fillSelect","mats","hitWall","imshow","cv","composeDisplay","config","Mat","zeros","height","width","type","copyTo","showBg","addWeighted","bgWeight","showEdge","edgeCvted","showEdgeValley","threshold","THRESH_BINARY","cvtColor","COLOR_GRAY2RGBA","edgeWeight","delete","showLabel","labelThresed","labelCvted","labelColorInv","labelColor","c","labelWeight","subtract","outputLabel","growValley","ones","CV_8U","dilated","dilate","Point","BORDER_CONSTANT","morphologyDefaultBorderValue","getRoi","undefined","setRoi","roi","x","y","DEFAULT_COMPOSE","composeUpdate","BehaviorSubject","roiUpdate","Subject","srcUpdate","edgeUpdate","labelUpdate","displayUpdate","MatUtilImpl","setVal","val","set","dimBy","amount","dimMask","pipe","subscribe","value","tap","src","imread","COLOR_RGB2GRAY","Canny","next","util","update","ValidCursorModes","0","1","2","3","4","5","6","CursorColors","hist","getRelPos","canvas","e","rect","getBoundingClientRect","clientX","left","clientY","top","getRoiPos","relPos","floor","App","useState","isFocused","setFocused","actionMode","setActionMode","cursorMode","setCursorMode","isMouseDown","setMouseDown","movePrevPos","setMovePrevPos","imageSrc","useRef","labelOutput","downloadLabel","useCallback","link","document","createElement","download","href","current","toDataURL","click","doAction","targets","pressed","action","range","j","undo","h","onImageLoad","currentTarget","onCanvasMouseEnter","onCanvasMouseLeave","onCanvasMouseMove","onCanvasMouseDown","onCanvasMouseUp","setModes","newCursorMode","newActionMode","onCanvasKeyPress","key","onCanvasFocus","onCanvasBlur","onCanvasWheel","preventDefault","oldPos","console","log","newRoi","deltaY","newPos","className","id","alt","ref","onLoad","style","name","onChange","URL","createObjectURL","target","files","Group","disabled","Button","ghost","onClick","onMouseEnter","onMouseLeave","onMouseMove","onMouseDown","onMouseUp","onKeyPress","onFocus","onBlur","onWheel","tabIndex","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.acb06d78.chunk.js","sourcesContent":["declare const cv: any\r\n\r\nvar bgMat: any\r\nvar edgeMat: any\r\nvar labelMat: any\r\n\r\nvar roiRect: any\r\n\r\nvar bgRoi: any\r\nexport var edgeRoi: any\r\nexport var labelRoi: any\r\nexport var display: any\r\n\r\nexport type ComposeConfig = {\r\n    showBg: boolean\r\n    bgWeight: number,\r\n    showEdge: boolean,\r\n    showEdgeValley: boolean,\r\n    edgeWeight: number,\r\n    showLabel: boolean,\r\n    labelColor: number[],\r\n    labelWeight: number,\r\n}\r\n\r\nexport const Pos = {\r\n    dist: (v1: number[], v2: number[]) => Math.sqrt(Math.pow(v1[0] - v2[0], 2) + Math.pow(v1[1] - v2[1], 2)),\r\n    add: (v1: number[], v2: number[]) => [v1[0] + v2[0], v1[1] + v2[1]],\r\n    sub: (v1: number[], v2: number[]) => [v1[0] - v2[0], v1[1] - v2[1]],\r\n    mul: (v: number[], m: number) => [v[0] * m, v[1] * m],\r\n    sum: (vecs: number[][]) => vecs.reduce((prev, curr) => Pos.add(prev, curr), [0, 0]),\r\n    nbrs: (p: number[]) => [\r\n        [p[0] - 1, p[1] - 1], [p[0], p[1] - 1], [p[0] + 1, p[1] - 1], [p[0] + 1, p[1]],\r\n        [p[0] + 1, p[1] + 1], [p[0], p[1] + 1], [p[0] - 1, p[1] + 1], [p[0] - 1, p[1]]\r\n    ],\r\n    closeNbrs: (p: number[]) => [\r\n        [p[0], p[1] - 1], [p[0] + 1, p[1]],\r\n        [p[0], p[1] + 1], [p[0] - 1, p[1]]\r\n    ],\r\n}\r\n\r\nexport const getVal = (mat: any, pos: number[]) => {\r\n    if (pos[0] >= 0 && pos[1] >= 0 && pos[0] < mat.cols && pos[1] < mat.rows)\r\n        return mat.ucharPtr(pos[0], pos[1])[0] as number\r\n    return 0\r\n}\r\n\r\nexport const fallPos = (mat: any, pos: number[], earlyStop = false) => {\r\n    let [curPos, curVal] = [pos, getVal(mat, pos)]\r\n    if (curVal === 0) return curPos\r\n    for (let r = 0; r < 20; r++) {\r\n        let nbrs = Pos.nbrs(curPos)\r\n        let vals = nbrs.map(pos => getVal(mat, pos))\r\n        const maxNbrVal = Math.max(...vals)\r\n        if (maxNbrVal === curVal) break\r\n        const maxNbrs = vals.map((v, i) => v === maxNbrVal ? i : -1).filter(i => i > -1)\r\n        if (earlyStop && maxNbrVal === 255) break\r\n        vals = vals.filter((_, i) => maxNbrs.includes(i))\r\n        nbrs = nbrs.filter((_, i) => maxNbrs.includes(i))\r\n        const direction = Pos.sub(Pos.mul(Pos.sum(nbrs), 1 / maxNbrs.length), curPos)\r\n        const dists = nbrs.map(pos => Pos.dist(pos, direction))\r\n        curPos = nbrs[dists.indexOf(Math.min(...dists))]\r\n        curVal = maxNbrVal\r\n        if (curVal === 255) break\r\n    }\r\n    return curPos\r\n}\r\n\r\nconst isBranch = (mat: any, pos: number[]) => {\r\n    let nbrs = Pos.nbrs(pos)\r\n    let vals = nbrs.map(p => getVal(mat, p)).map(v => v === 255 ? 1 : 0)\r\n    let changes = 0\r\n    if ((vals[7] && vals[0] && vals[1]) ||\r\n        (vals[1] && vals[2] && vals[3]) ||\r\n        (vals[3] && vals[4] && vals[5]) ||\r\n        (vals[5] && vals[6] && vals[7])) return true\r\n    for (let i = 0; i < 8; i++) changes += vals[i] ^ vals[(i + 1) % 8]\r\n    return changes > 4\r\n}\r\n\r\nexport const selectTillBranch = (mat: any, pos: number[], inclusive = false) => {\r\n    if (getVal(mat, pos) !== 255) return []\r\n    if (isBranch(mat, pos)) return [pos]\r\n    const res: number[][] = []\r\n    const stack: number[][] = []\r\n    const visited: { [p: string]: boolean } = {}\r\n    stack.push(pos)\r\n    while (stack.length) {\r\n        let curPos = stack.pop()!\r\n        if (visited[curPos.toString()]) continue\r\n        visited[curPos.toString()] = true\r\n        res.push(curPos)\r\n        const edgeNbrs = Pos.nbrs(curPos).filter(p => getVal(mat, p) === 255)\r\n        const branchedNbrs = edgeNbrs.filter(p => isBranch(mat, p))\r\n        if (branchedNbrs.length) {\r\n            if (inclusive) branchedNbrs.forEach(p => res.push(p))\r\n            continue\r\n        }\r\n        edgeNbrs.forEach(p => stack.push(p))\r\n    }\r\n    return res\r\n}\r\n\r\nexport const needRepair = (mat: any[], pos: number[]) => {\r\n    if (getVal(mat, pos) === 255) return false\r\n    let nbrs = Pos.nbrs(pos)\r\n    let vals = nbrs.map(p => getVal(mat, p)).map(v => v === 255 ? 1 : 0)\r\n    const sum = vals.reduce((prev, curr) => prev + curr, 0 as number)\r\n    if (sum >= 7) return true\r\n    let changes = 0\r\n    for (let i = 0; i < 8; i++) changes += vals[i] ^ vals[(i + 1) % 8]\r\n    return changes >= 4\r\n}\r\n\r\nexport const fillSelect = (mats: any[], pos: number[]) => {\r\n    const hitWall = (p: number[]) => mats.filter(mat => getVal(mat, p) === 255).length > 0\r\n    if (hitWall(pos)) return []\r\n    const res: number[][] = []\r\n    const stack: number[][] = []\r\n    const visited: { [p: string]: boolean } = {}\r\n    stack.push(pos)\r\n    while (stack.length) {\r\n        let curPos = stack.pop()!\r\n        if (visited[curPos.toString()]) continue\r\n        visited[curPos.toString()] = true\r\n        res.push(curPos)\r\n        const nonEdgeNbrs = Pos.closeNbrs(curPos).filter(p => !hitWall(p))\r\n        nonEdgeNbrs.filter(p => !visited[p.toString()]).forEach(p => stack.push(p))\r\n        if (res.length > 1000) break\r\n    }\r\n    return res\r\n}\r\n\r\nexport const imshow = (mat: any) => cv.imshow('canvas', mat)\r\n\r\nexport const setVal = (mat: any, pos: number[], val: number[]) => {\r\n    if (pos[0] >= 0 && pos[1] >= 0 && pos[0] < mat.cols && pos[1] < mat.rows)\r\n        mat.ucharPtr(pos[0], pos[1]).set(val)\r\n}\r\n\r\nexport const dimBy = (mat: any, amount: number) => {\r\n    const dimMask = new cv.Mat(mat.rows, mat.cols, mat.type(), [0, 0, 0, amount])\r\n    cv.subtract(mat, dimMask, mat)\r\n    dimMask.delete()\r\n}\r\n\r\nexport const composeDisplay = (display: any, config: ComposeConfig) => {\r\n    const blank = new cv.Mat.zeros(roiRect.height, roiRect.width, bgMat.type())\r\n    blank.copyTo(display)\r\n    if (config.showBg) cv.addWeighted(display, 1, bgRoi, config.bgWeight, 0.0, display)\r\n    if (config.showEdge) {\r\n        const edgeCvted = new cv.Mat.zeros(roiRect.height, roiRect.width, edgeRoi.type())\r\n        if (config.showEdgeValley) {\r\n            cv.add(edgeRoi, edgeCvted, edgeCvted)\r\n        } else {\r\n            cv.threshold(edgeRoi, edgeCvted, 254, 255, cv.THRESH_BINARY)\r\n        }\r\n        cv.cvtColor(edgeCvted, edgeCvted, cv.COLOR_GRAY2RGBA)\r\n        cv.addWeighted(display, 1, edgeCvted, config.edgeWeight, 0.0, display)\r\n        edgeCvted.delete()\r\n    }\r\n    if (config.showLabel) {\r\n        const labelThresed = new cv.Mat()\r\n        cv.threshold(labelRoi, labelThresed, 254, 255, cv.THRESH_BINARY)\r\n        const labelCvted = new cv.Mat()\r\n        cv.cvtColor(labelThresed, labelCvted, cv.COLOR_GRAY2RGBA)\r\n        const labelColorInv = new cv.Mat(labelCvted.rows, labelCvted.cols, labelCvted.type(), config.labelColor.map(c => 255 - c))\r\n        cv.addWeighted(display, 1, labelCvted, config.labelWeight, 0.0, display)\r\n        cv.subtract(display, labelColorInv, display, labelThresed)\r\n        labelThresed.delete()\r\n        labelCvted.delete()\r\n        labelColorInv.delete()\r\n    }\r\n}\r\n\r\nexport const outputLabel = () => {\r\n    const labelThresed = new cv.Mat()\r\n    cv.threshold(labelMat, labelThresed, 254, 255, cv.THRESH_BINARY)\r\n    cv.imshow('output', labelThresed)\r\n}\r\n\r\nexport const growValley = (mat: any) => {\r\n    cv.threshold(mat, mat, 254, 255, cv.THRESH_BINARY);\r\n    for (let i = 2; i < 6; i++) {\r\n        let filter = cv.Mat.ones(i, i, cv.CV_8U);\r\n        let dilated = new cv.Mat()\r\n        cv.dilate(mat, dilated, filter, new cv.Point(-1, -1), 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())\r\n        cv.addWeighted(mat, 0.8, dilated, 0.2, 0.0, mat);\r\n        filter.delete()\r\n        dilated.delete()\r\n    }\r\n}\r\n\r\nexport const initMats = (src: HTMLImageElement) => {\r\n    bgMat = cv.imread(src)\r\n    edgeMat = new cv.Mat()\r\n    cv.cvtColor(bgMat, edgeMat, cv.COLOR_RGB2GRAY, 0)\r\n    cv.Canny(edgeMat, edgeMat, 50, 100, 3, false)\r\n    labelMat = new cv.Mat.zeros(edgeMat.rows, edgeMat.cols, edgeMat.type())\r\n    setRoi({ x: 0, y: 0, width: Math.min(400, src.width), height: Math.min(400, src.height) })\r\n    growValley(edgeRoi)\r\n}\r\n\r\nexport const getRoi = () => roiRect ? { ...roiRect } : undefined\r\n\r\nexport const setRoi = (roi: any) => {\r\n    if (roi.width < 16 || roi.height < 16) {\r\n        if (roiRect.width === 16 || roiRect.height === 16) return\r\n        roi.width = roi.height = 16\r\n    }\r\n    if (roi.width > 1024 || roi.height > 1024) {\r\n        if (roiRect.width === 1024 || roiRect.height === 1024) return\r\n        roi.width = roi.height = 1024\r\n    }\r\n    if (roi.x >= 0 && roi.y >= 0 && roi.x + roi.width < bgMat.cols && roi.y + roi.height < bgMat.rows) {\r\n        if (roiRect) {\r\n            display.delete()\r\n            bgRoi.delete()\r\n            edgeRoi.delete()\r\n            labelRoi.delete()\r\n        }\r\n        display = new cv.Mat.zeros(roi.height, roi.width, bgMat.type())\r\n        bgRoi = bgMat.roi(roi)\r\n        edgeRoi = edgeMat.roi(roi)\r\n        labelRoi = labelMat.roi(roi)\r\n        roiRect = roi\r\n    }\r\n}\r\n","import { Subject, BehaviorSubject } from 'rxjs'\r\nimport { tap, filter } from 'rxjs/operators'\r\n\r\nimport { edgeRoi, labelRoi, display, imshow, setVal, growValley, composeDisplay, dimBy, initMats, setRoi, ComposeConfig } from './model'\r\n\r\ntype MatUtil = {\r\n    setVal: (mat: any, pos: number[], val: number[]) => void\r\n    dimBy: (mat: any, amount: number) => void\r\n}\r\n\r\ntype MatUpdate = (mat: any, util: MatUtil) => void\r\n\r\nexport const DEFAULT_COMPOSE: ComposeConfig = {\r\n    showBg: true,\r\n    bgWeight: 1,\r\n    showEdge: true,\r\n    showEdgeValley: false,\r\n    edgeWeight: 0.4,\r\n    showLabel: true,\r\n    labelColor: [255, 255, 0, 255],\r\n    labelWeight: 0.8,\r\n}\r\n\r\nexport const composeUpdate = new BehaviorSubject<ComposeConfig>(DEFAULT_COMPOSE)\r\nexport const roiUpdate = new Subject<any>()\r\n\r\nexport const srcUpdate = new Subject<HTMLImageElement>()\r\nexport const edgeUpdate = new Subject<MatUpdate>()\r\nexport const labelUpdate = new Subject<MatUpdate>()\r\nexport const displayUpdate = new Subject<MatUpdate>()\r\n\r\nconst MatUtilImpl: MatUtil = {\r\n    setVal: setVal,\r\n    dimBy: dimBy,\r\n}\r\n\r\ncomposeUpdate\r\n    .pipe(\r\n        filter(() => display),\r\n    )\r\n    .subscribe(() => {\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nroiUpdate\r\n    .pipe(\r\n        tap(setRoi)\r\n    )\r\n    .subscribe(() => {\r\n        growValley(edgeRoi)\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nsrcUpdate\r\n    .pipe(\r\n        tap(initMats)\r\n    )\r\n    .subscribe(\r\n        () => displayUpdate.next((mat, util) => util.dimBy(mat, 96))\r\n    )\r\n\r\nedgeUpdate\r\n    .pipe(\r\n        filter(() => edgeRoi),\r\n        tap(update => update(edgeRoi, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        growValley(edgeRoi)\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nlabelUpdate\r\n    .pipe(\r\n        filter(() => labelRoi),\r\n        tap(update => update(labelRoi, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\ndisplayUpdate\r\n    .pipe(\r\n        filter(() => display),\r\n        tap(() => composeDisplay(display, composeUpdate.value)),\r\n        tap(update => update(display, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        imshow(display)\r\n    })\r\n","import React, { useRef, SyntheticEvent, MouseEvent, KeyboardEvent, WheelEvent, useState, useCallback } from 'react'\nimport { Radio, Button } from 'antd'\nimport 'antd/dist/antd.css'\n\nimport { srcUpdate, edgeUpdate, labelUpdate, displayUpdate, composeUpdate, DEFAULT_COMPOSE, roiUpdate } from './controller'\nimport { edgeRoi, labelRoi, getVal, fallPos, selectTillBranch, fillSelect, needRepair, getRoi, outputLabel } from './model'\nimport './App.css'\n\ntype ActionMode = 0 | 1 | 2 | 3 | 4 | 5 | 6\nconst NO_ACTION: ActionMode = 0\nconst WIPE_EDGE: ActionMode = 1\nconst DRAW_EDGE: ActionMode = 2\nconst REPAIR_EDGE: ActionMode = 3\nconst FILL_LABEL: ActionMode = 4\nconst VIEW_LABEL: ActionMode = 5\nconst MOVE_CANVAS: ActionMode = 6\n\ntype CursorMode = 0 | 1 | 2 | 3\nconst DISABLED = 0\nconst FALLING = 1\nconst ADHERE = 2\nconst FLOATING = 3\n\nconst ValidCursorModes = {\n    0: [FALLING, ADHERE, FLOATING],\n    1: [FALLING, FLOATING],\n    2: [ADHERE, FLOATING],\n    3: [FLOATING],\n    4: [FLOATING],\n    5: [DISABLED],\n    6: [DISABLED],\n}\n\nconst CursorColors = {\n    0: [0, 0, 0, 0],\n    1: [0, 255, 255, 255],\n    2: [255, 0, 255, 255],\n    3: [255, 0, 0, 255],\n}\n\ntype EditHistory = {\n    action: ActionMode,\n    targets: number[][]\n}\nvar hist: EditHistory[] = []\n\nconst getRelPos = (canvas: HTMLCanvasElement, e: React.MouseEvent<HTMLCanvasElement>) => {\n    const rect = canvas.getBoundingClientRect()\n    return [(e.clientX - rect.left) / rect.width, (e.clientY - rect.top) / rect.height]\n}\n\nconst getRoiPos = (roi: any, relPos: number[]) => {\n    const res = relPos.map((p, i) => Math.floor(p * [roi.width, roi.height][i]))\n    return [res[1], res[0]]\n}\n\nexport default function App() {\n    const [isFocused, setFocused] = useState(false)\n    const [actionMode, setActionMode] = useState<ActionMode>(MOVE_CANVAS)\n    const [cursorMode, setCursorMode] = useState<CursorMode>(FALLING)\n    const [isMouseDown, setMouseDown] = useState(false)\n    const [movePrevPos, setMovePrevPos] = useState([-1, -1])\n    const imageSrc = useRef<HTMLImageElement>(null)\n    const labelOutput = useRef<HTMLCanvasElement>(null)\n\n    const downloadLabel = useCallback(() => {\n        const link = document.createElement('a')\n        link.download = 'label.png'\n        link.href = labelOutput.current?.toDataURL(\"image/png\")!\n        link.click();\n    }, [])\n\n    const doAction = useCallback((pos: number[], pressed = false) => {\n        let targets: number[][]\n        switch (cursorMode) {\n            case DISABLED:\n                targets = []\n                break\n            case FLOATING:\n                targets = [pos]\n                break\n            case FALLING:\n                targets = selectTillBranch(edgeRoi, fallPos(edgeRoi, pos))\n                break\n            case ADHERE:\n                targets = [fallPos(edgeRoi, pos, true)].filter(p => getVal(edgeRoi, p))\n        }\n        if (actionMode === MOVE_CANVAS) {\n            if (!isMouseDown) return\n            if (movePrevPos[0] === -1) return\n            const roi = getRoi()\n            roiUpdate.next({\n                ...roi,\n                x: roi.x + movePrevPos[1] - pos[1],\n                y: roi.y + movePrevPos[0] - pos[0],\n            })\n            hist.push({ action: MOVE_CANVAS, targets: [movePrevPos, pos] })\n        } else if (actionMode === NO_ACTION || !(isMouseDown || pressed)) {\n            displayUpdate.next((mat, util) => targets.forEach(p =>\n                util.setVal(mat, p, CursorColors[cursorMode]))\n            )\n        } else {\n            if (!targets.length) return\n            switch (actionMode) {\n                case WIPE_EDGE:\n                    targets = targets.filter(p => getVal(edgeRoi, p))\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [0])))\n                    break\n                case DRAW_EDGE:\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n                    break\n                case REPAIR_EDGE:\n                    const p = targets.pop()!\n                    const range = 20\n                    for (let i = p[0] - range; i < p[0] + range; i++)\n                        for (let j = p[1] - range; j < p[1] + range; j++)\n                            targets.push([i, j])\n                    targets = targets.filter(p => needRepair(edgeRoi, p))\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n                    break\n                case FILL_LABEL:\n                    targets = fillSelect([edgeRoi, labelRoi], targets[0])\n                    labelUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n            }\n            if (!targets.length) return\n            hist.push({ action: actionMode, targets: targets })\n        }\n    }, [actionMode, cursorMode, isMouseDown, movePrevPos])\n\n    const undo = useCallback((h: EditHistory) => {\n        switch (h.action) {\n            case WIPE_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [255])))\n                break\n            case DRAW_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case REPAIR_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case FILL_LABEL:\n                labelUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case MOVE_CANVAS:\n                const roi = getRoi()\n                roiUpdate.next({\n                    ...roi,\n                    x: roi.x + h.targets[1][1] - h.targets[0][1],\n                    y: roi.y + h.targets[1][0] - h.targets[0][0],\n                })\n        }\n    }, [])\n\n    const onImageLoad = useCallback((e: SyntheticEvent<HTMLImageElement, Event>) => {\n        srcUpdate.next(e.currentTarget)\n    }, [])\n\n    const onCanvasMouseEnter = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        displayUpdate.next((mat, util) => {\n            if (!isFocused) util.dimBy(mat, 48)\n        })\n    }, [isFocused])\n\n    const onCanvasMouseLeave = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        setMouseDown(false)\n        setMovePrevPos([-1, -1])\n        displayUpdate.next((mat, util) => {\n            if (!isFocused) util.dimBy(mat, 96)\n        })\n    }, [isFocused])\n\n    const onCanvasMouseMove = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!isFocused) return\n        if (!getRoi()) return\n        const pos = getRoiPos(getRoi(), getRelPos(e.currentTarget, e))\n        if (pos.toString() === movePrevPos.toString()) return\n        doAction(pos)\n        setMovePrevPos(pos)\n    }, [isFocused, movePrevPos, doAction])\n\n    const onCanvasMouseDown = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        setMovePrevPos([-1, -1])\n        if (!isFocused) return\n        setMouseDown(true)\n        if (actionMode === NO_ACTION) return\n        if (!getRoi()) return\n        const pos = getRoiPos(getRoi(), getRelPos(e.currentTarget, e))\n        doAction(pos, true)\n    }, [isFocused, actionMode, doAction])\n\n    const onCanvasMouseUp = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        setMouseDown(false)\n    }, [])\n\n    const setModes = useCallback((newCursorMode: CursorMode, newActionMode: ActionMode) => {\n        if (cursorMode !== newCursorMode) {\n            while (ValidCursorModes[newActionMode].indexOf(newCursorMode) < 0)\n                newCursorMode = (newCursorMode + 1) % 3 as CursorMode\n            setCursorMode(newCursorMode)\n        }\n        if (actionMode !== newActionMode) {\n            setActionMode(newActionMode)\n            switch (newActionMode) {\n                case WIPE_EDGE:\n                    setCursorMode(FALLING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, showEdgeValley: true, bgWeight: 0.5 })\n                    break\n                case DRAW_EDGE:\n                    setCursorMode(ADHERE)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.8, edgeWeight: 0.8 })\n                    break\n                case REPAIR_EDGE:\n                    setCursorMode(FLOATING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.8, edgeWeight: 0.8 })\n                    break\n                case FILL_LABEL:\n                    setCursorMode(FLOATING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.6 })\n                    break\n                case VIEW_LABEL:\n                    setCursorMode(DISABLED)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, showEdge: false, labelWeight: 0.4 })\n                    break\n                case MOVE_CANVAS:\n                    setCursorMode(DISABLED)\n                    composeUpdate.next(DEFAULT_COMPOSE)\n                    break\n                default:\n                    setCursorMode(FALLING)\n                    composeUpdate.next(DEFAULT_COMPOSE)\n            }\n        }\n    }, [cursorMode, actionMode])\n\n\n    const onCanvasKeyPress = useCallback((e: KeyboardEvent<HTMLCanvasElement>) => {\n        setMovePrevPos([-1, -1])\n        let newCursorMode: CursorMode = cursorMode, newActionMode: ActionMode = actionMode\n        switch (e.key) {\n            case \"f\":\n                newCursorMode = (cursorMode + 1) % 3 as CursorMode\n                break\n            case \"z\":\n                if (hist.length) undo(hist.pop()!)\n                break\n            case \"s\":\n                outputLabel()\n                downloadLabel()\n                break\n            case \"w\":\n                newActionMode = WIPE_EDGE\n                break\n            case \"e\":\n                newActionMode = DRAW_EDGE\n                break\n            case \"r\":\n                newActionMode = REPAIR_EDGE\n                break\n            case \"d\":\n                newActionMode = FILL_LABEL\n                break\n            case \"v\":\n                newActionMode = VIEW_LABEL\n                break\n            case \"q\":\n                newActionMode = MOVE_CANVAS\n                break\n            default:\n                newActionMode = NO_ACTION\n        }\n        setModes(newCursorMode, newActionMode)\n    }, [actionMode, cursorMode, undo, setModes, downloadLabel])\n\n    const onCanvasFocus = useCallback(() => {\n        setFocused(true)\n    }, [])\n\n    const onCanvasBlur = useCallback(() => {\n        setFocused(false)\n        setMouseDown(false)\n        setMovePrevPos([-1, -1])\n        displayUpdate.next((mat, util) => util.dimBy(mat, 96))\n    }, [])\n\n    const onCanvasWheel = useCallback((e: WheelEvent<HTMLCanvasElement>) => {\n        if (actionMode !== MOVE_CANVAS) return\n        e.preventDefault()\n        const relPos = getRelPos(e.currentTarget, e)\n        const roi = getRoi()\n        const oldPos = getRoiPos(roi, relPos)\n        console.log(oldPos)\n        const newRoi = {\n            ...roi,\n            width: roi.width - e.deltaY,\n            height: roi.height - e.deltaY,\n        }\n        const newPos = getRoiPos(newRoi, relPos)\n        console.log(newPos)\n        roiUpdate.next({\n            ...newRoi,\n            x: roi.x + oldPos[1] - newPos[1],\n            y: roi.y + oldPos[0] - newPos[0],\n        })\n    }, [actionMode])\n\n    return (\n        <div className=\"App\">\n            <div className=\"input\">\n                <img id=\"imageSrc\" alt={\"Canvas Input\"} ref={imageSrc} onLoad={onImageLoad} style={{ display: \"none\" }} />\n                <input type=\"file\" id=\"fileInput\" name=\"file\" onChange={(e) => {\n                    imageSrc.current!.src = URL.createObjectURL(e.target.files![0]);\n                }} />\n            </div>\n            <div className=\"radio\">\n                <span>Action: </span>\n                <Radio.Group value={actionMode} onChange={(e) => setModes(cursorMode, e.target.value)} disabled={!getRoi()}>\n                    <Radio.Button value={NO_ACTION}>No Action</Radio.Button>\n                    <Radio.Button value={MOVE_CANVAS}>Move Canvas (Q)</Radio.Button>\n                    <Radio.Button value={WIPE_EDGE}>Wipe Edge (W)</Radio.Button>\n                    <Radio.Button value={DRAW_EDGE}>Draw Edge (E)</Radio.Button>\n                    <Radio.Button value={REPAIR_EDGE}>Repair Edge (R)</Radio.Button>\n                    <Radio.Button value={FILL_LABEL}>Fill Label (D)</Radio.Button>\n                    <Radio.Button value={VIEW_LABEL}>View Label (V)</Radio.Button>\n                </Radio.Group>\n            </div>\n            <div className=\"radio\">\n                <span>Cursor (F): </span>\n                <Radio.Group value={cursorMode} onChange={(e) => setModes(e.target.value, actionMode)} disabled={!getRoi()}>\n                    <Radio.Button value={FALLING} disabled={ValidCursorModes[actionMode].indexOf(FALLING) < 0}>Fall to Edge</Radio.Button>\n                    <Radio.Button value={ADHERE} disabled={ValidCursorModes[actionMode].indexOf(ADHERE) < 0}>Adhere to Edge</Radio.Button>\n                    <Radio.Button value={FLOATING} disabled={ValidCursorModes[actionMode].indexOf(FLOATING) < 0}>Floating</Radio.Button>\n                </Radio.Group>\n                <Button className=\"button\" type=\"danger\" ghost onClick={() => { if (hist.length) undo(hist.pop()!) }} disabled={!getRoi()}>Undo (Z)</Button>\n                <Button className=\"button\" type=\"primary\" ghost onClick={() => { outputLabel(); downloadLabel() }} disabled={!getRoi()}>Save Label (S)</Button>\n            </div>\n            <div className=\"canvas\">\n                <canvas\n                    id=\"canvas\"\n                    className={actionMode === MOVE_CANVAS ? \"moving\" : \"\"}\n                    onMouseEnter={onCanvasMouseEnter}\n                    onMouseLeave={onCanvasMouseLeave}\n                    onMouseMove={onCanvasMouseMove}\n                    onMouseDown={onCanvasMouseDown}\n                    onMouseUp={onCanvasMouseUp}\n                    onKeyPress={onCanvasKeyPress}\n                    onFocus={onCanvasFocus}\n                    onBlur={onCanvasBlur}\n                    onWheel={onCanvasWheel}\n                    tabIndex={1000}\n                />\n            </div>\n            <canvas id=\"output\" ref={labelOutput} />\n        </div>\n    );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
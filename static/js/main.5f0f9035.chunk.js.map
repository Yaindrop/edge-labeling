{"version":3,"sources":["model.ts","controller.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["bgMat","edgeMat","labelMat","roiRect","bgRoi","edgeRoi","labelRoi","display","RoiRange","Pos","dist","v1","v2","Math","sqrt","pow","add","sub","mul","v","m","sum","vecs","reduce","prev","curr","nbrs","p","closeNbrs","getVal","mat","pos","cols","rows","ucharPtr","fallPos","earlyStop","curPos","curVal","r","vals","map","maxNbrVal","max","maxNbrs","i","filter","_","includes","direction","length","dists","indexOf","min","isBranch","changes","selectTillBranch","inclusive","res","stack","visited","push","pop","toString","edgeNbrs","branchedNbrs","forEach","needRepair","fillSelect","mats","hitWall","imshow","cv","composeDisplay","config","blank","Mat","zeros","height","width","type","copyTo","delete","showBg","addWeighted","bgWeight","showEdge","edgeCvted","showEdgeValley","threshold","THRESH_BINARY","cvtColor","COLOR_GRAY2RGBA","edgeWeight","showLabel","labelThresed","labelCvted","labelColorInv","labelColor","c","labelWeight","subtract","outputLabel","growValley","ones","CV_8U","dilated","dilate","Point","BORDER_CONSTANT","morphologyDefaultBorderValue","getRoi","undefined","fitRange","n","setRoi","roi","x","y","restrictRoi","console","log","DEFAULT_COMPOSE","composeUpdate","BehaviorSubject","roiUpdate","Subject","srcUpdate","edgeUpdate","labelUpdate","displayUpdate","MatUtilImpl","setVal","val","set","dimBy","amount","dimMask","pipe","subscribe","value","tap","src","imread","COLOR_RGB2GRAY","Canny","next","util","update","ValidCursorModes","0","1","2","3","4","5","6","CursorColors","hist","getRelPos","canvas","e","rect","getBoundingClientRect","clientX","left","clientY","top","getRoiPos","relPos","floor","App","useState","isFocused","setFocused","actionMode","setActionMode","cursorMode","setCursorMode","isMouseDown","setMouseDown","movePrevPos","setMovePrevPos","imageSrc","useRef","labelOutput","downloadLabel","useCallback","link","document","createElement","download","href","current","toDataURL","click","doAction","targets","pressed","action","range","j","undo","h","setModes","newCursorMode","newActionMode","onImageLoad","currentTarget","onCanvasMouseEnter","onCanvasMouseLeave","onCanvasMouseMove","onCanvasMouseDown","onCanvasMouseUp","onCanvasKeyPress","key","onCanvasFocus","onCanvasBlur","onCanvasWheel","preventDefault","oldPos","newRoi","deltaY","ceil","newPos","className","id","alt","ref","onLoad","style","name","onChange","URL","createObjectURL","target","files","Group","disabled","Button","ghost","onClick","onMouseEnter","onMouseLeave","onMouseMove","onMouseDown","onMouseUp","onKeyPress","onFocus","onBlur","onWheel","tabIndex","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5f0f9035.chunk.js","sourcesContent":["declare const cv: any\r\n\r\nvar bgMat: any\r\nvar edgeMat: any\r\nvar labelMat: any\r\n\r\nexport const RoiRange = {\r\n    width: [16, 800],\r\n    height: [16, 800],\r\n}\r\n\r\nvar roiRect: any\r\n\r\nvar bgRoi: any\r\nexport var edgeRoi: any\r\nexport var labelRoi: any\r\nexport var display: any\r\n\r\nexport type ComposeConfig = {\r\n    showBg: boolean\r\n    bgWeight: number,\r\n    showEdge: boolean,\r\n    showEdgeValley: boolean,\r\n    edgeWeight: number,\r\n    showLabel: boolean,\r\n    labelColor: number[],\r\n    labelWeight: number,\r\n}\r\n\r\nexport const Pos = {\r\n    dist: (v1: number[], v2: number[]) => Math.sqrt(Math.pow(v1[0] - v2[0], 2) + Math.pow(v1[1] - v2[1], 2)),\r\n    add: (v1: number[], v2: number[]) => [v1[0] + v2[0], v1[1] + v2[1]],\r\n    sub: (v1: number[], v2: number[]) => [v1[0] - v2[0], v1[1] - v2[1]],\r\n    mul: (v: number[], m: number) => [v[0] * m, v[1] * m],\r\n    sum: (vecs: number[][]) => vecs.reduce((prev, curr) => Pos.add(prev, curr), [0, 0]),\r\n    nbrs: (p: number[]) => [\r\n        [p[0] - 1, p[1] - 1], [p[0], p[1] - 1], [p[0] + 1, p[1] - 1], [p[0] + 1, p[1]],\r\n        [p[0] + 1, p[1] + 1], [p[0], p[1] + 1], [p[0] - 1, p[1] + 1], [p[0] - 1, p[1]]\r\n    ],\r\n    closeNbrs: (p: number[]) => [\r\n        [p[0], p[1] - 1], [p[0] + 1, p[1]],\r\n        [p[0], p[1] + 1], [p[0] - 1, p[1]]\r\n    ],\r\n}\r\n\r\nexport const getVal = (mat: any, pos: number[]) => {\r\n    if (pos[0] >= 0 && pos[1] >= 0 && pos[0] < mat.cols && pos[1] < mat.rows)\r\n        return mat.ucharPtr(pos[0], pos[1])[0] as number\r\n    return 0\r\n}\r\n\r\nexport const fallPos = (mat: any, pos: number[], earlyStop = false) => {\r\n    let [curPos, curVal] = [pos, getVal(mat, pos)]\r\n    if (curVal === 0) return curPos\r\n    for (let r = 0; r < 20; r++) {\r\n        let nbrs = Pos.nbrs(curPos)\r\n        let vals = nbrs.map(pos => getVal(mat, pos))\r\n        const maxNbrVal = Math.max(...vals)\r\n        if (maxNbrVal === curVal) break\r\n        const maxNbrs = vals.map((v, i) => v === maxNbrVal ? i : -1).filter(i => i > -1)\r\n        if (earlyStop && maxNbrVal === 255) break\r\n        vals = vals.filter((_, i) => maxNbrs.includes(i))\r\n        nbrs = nbrs.filter((_, i) => maxNbrs.includes(i))\r\n        const direction = Pos.sub(Pos.mul(Pos.sum(nbrs), 1 / maxNbrs.length), curPos)\r\n        const dists = nbrs.map(pos => Pos.dist(pos, direction))\r\n        curPos = nbrs[dists.indexOf(Math.min(...dists))]\r\n        curVal = maxNbrVal\r\n        if (curVal === 255) break\r\n    }\r\n    return curPos\r\n}\r\n\r\nconst isBranch = (mat: any, pos: number[]) => {\r\n    let nbrs = Pos.nbrs(pos)\r\n    let vals = nbrs.map(p => getVal(mat, p)).map(v => v === 255 ? 1 : 0)\r\n    let changes = 0\r\n    if ((vals[7] && vals[0] && vals[1]) ||\r\n        (vals[1] && vals[2] && vals[3]) ||\r\n        (vals[3] && vals[4] && vals[5]) ||\r\n        (vals[5] && vals[6] && vals[7])) return true\r\n    for (let i = 0; i < 8; i++) changes += vals[i] ^ vals[(i + 1) % 8]\r\n    return changes > 4\r\n}\r\n\r\nexport const selectTillBranch = (mat: any, pos: number[], inclusive = false) => {\r\n    if (getVal(mat, pos) !== 255) return []\r\n    if (isBranch(mat, pos)) return [pos]\r\n    const res: number[][] = []\r\n    const stack: number[][] = []\r\n    const visited: { [p: string]: boolean } = {}\r\n    stack.push(pos)\r\n    while (stack.length) {\r\n        let curPos = stack.pop()!\r\n        if (visited[curPos.toString()]) continue\r\n        visited[curPos.toString()] = true\r\n        res.push(curPos)\r\n        const edgeNbrs = Pos.nbrs(curPos).filter(p => getVal(mat, p) === 255)\r\n        const branchedNbrs = edgeNbrs.filter(p => isBranch(mat, p))\r\n        if (branchedNbrs.length) {\r\n            if (inclusive) branchedNbrs.forEach(p => res.push(p))\r\n            continue\r\n        }\r\n        edgeNbrs.forEach(p => stack.push(p))\r\n    }\r\n    return res\r\n}\r\n\r\nexport const needRepair = (mat: any[], pos: number[]) => {\r\n    if (getVal(mat, pos) === 255) return false\r\n    let nbrs = Pos.nbrs(pos)\r\n    let vals = nbrs.map(p => getVal(mat, p)).map(v => v === 255 ? 1 : 0)\r\n    const sum = vals.reduce((prev, curr) => prev + curr, 0 as number)\r\n    if (sum >= 7) return true\r\n    let changes = 0\r\n    for (let i = 0; i < 8; i++) changes += vals[i] ^ vals[(i + 1) % 8]\r\n    return changes >= 4\r\n}\r\n\r\nexport const fillSelect = (mats: any[], pos: number[]) => {\r\n    const hitWall = (p: number[]) => mats.filter(mat => getVal(mat, p) === 255).length > 0\r\n    if (hitWall(pos)) return []\r\n    const res: number[][] = []\r\n    const stack: number[][] = []\r\n    const visited: { [p: string]: boolean } = {}\r\n    stack.push(pos)\r\n    while (stack.length) {\r\n        let curPos = stack.pop()!\r\n        if (visited[curPos.toString()]) continue\r\n        visited[curPos.toString()] = true\r\n        res.push(curPos)\r\n        const nonEdgeNbrs = Pos.closeNbrs(curPos).filter(p => !hitWall(p))\r\n        nonEdgeNbrs.filter(p => !visited[p.toString()]).forEach(p => stack.push(p))\r\n        if (res.length > 1000) break\r\n    }\r\n    return res\r\n}\r\n\r\nexport const imshow = (mat: any) => cv.imshow('canvas', mat)\r\n\r\nexport const setVal = (mat: any, pos: number[], val: number[]) => {\r\n    if (pos[0] >= 0 && pos[1] >= 0 && pos[0] < mat.cols && pos[1] < mat.rows)\r\n        mat.ucharPtr(pos[0], pos[1]).set(val)\r\n}\r\n\r\nexport const dimBy = (mat: any, amount: number) => {\r\n    const dimMask = new cv.Mat(mat.rows, mat.cols, mat.type(), [0, 0, 0, amount])\r\n    cv.subtract(mat, dimMask, mat)\r\n    dimMask.delete()\r\n}\r\n\r\nexport const composeDisplay = (display: any, config: ComposeConfig) => {\r\n    const blank = new cv.Mat.zeros(roiRect.height, roiRect.width, bgMat.type())\r\n    blank.copyTo(display)\r\n    blank.delete()\r\n    if (config.showBg) cv.addWeighted(display, 1, bgRoi, config.bgWeight, 0.0, display)\r\n    if (config.showEdge) {\r\n        const edgeCvted = new cv.Mat.zeros(roiRect.height, roiRect.width, edgeRoi.type())\r\n        if (config.showEdgeValley) {\r\n            cv.add(edgeRoi, edgeCvted, edgeCvted)\r\n        } else {\r\n            cv.threshold(edgeRoi, edgeCvted, 254, 255, cv.THRESH_BINARY)\r\n        }\r\n        cv.cvtColor(edgeCvted, edgeCvted, cv.COLOR_GRAY2RGBA)\r\n        cv.addWeighted(display, 1, edgeCvted, config.edgeWeight, 0.0, display)\r\n        edgeCvted.delete()\r\n    }\r\n    if (config.showLabel) {\r\n        const labelThresed = new cv.Mat()\r\n        cv.threshold(labelRoi, labelThresed, 254, 255, cv.THRESH_BINARY)\r\n        const labelCvted = new cv.Mat()\r\n        cv.cvtColor(labelThresed, labelCvted, cv.COLOR_GRAY2RGBA)\r\n        const labelColorInv = new cv.Mat(labelCvted.rows, labelCvted.cols, labelCvted.type(), config.labelColor.map(c => 255 - c))\r\n        cv.addWeighted(display, 1, labelCvted, config.labelWeight, 0.0, display)\r\n        cv.subtract(display, labelColorInv, display, labelThresed)\r\n        labelThresed.delete()\r\n        labelCvted.delete()\r\n        labelColorInv.delete()\r\n    }\r\n}\r\n\r\nexport const outputLabel = () => {\r\n    const labelThresed = new cv.Mat()\r\n    cv.threshold(labelMat, labelThresed, 254, 255, cv.THRESH_BINARY)\r\n    cv.imshow('output', labelThresed)\r\n}\r\n\r\nexport const growValley = (mat: any) => {\r\n    cv.threshold(mat, mat, 254, 255, cv.THRESH_BINARY);\r\n    for (let i = 2; i < 6; i++) {\r\n        let filter = cv.Mat.ones(i, i, cv.CV_8U);\r\n        let dilated = new cv.Mat()\r\n        cv.dilate(mat, dilated, filter, new cv.Point(-1, -1), 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())\r\n        cv.addWeighted(mat, 0.8, dilated, 0.2, 0.0, mat);\r\n        filter.delete()\r\n        dilated.delete()\r\n    }\r\n}\r\n\r\nexport const initMats = (src: HTMLImageElement) => {\r\n    bgMat = cv.imread(src)\r\n    edgeMat = new cv.Mat()\r\n    cv.cvtColor(bgMat, edgeMat, cv.COLOR_RGB2GRAY, 0)\r\n    cv.Canny(edgeMat, edgeMat, 50, 100, 3, false)\r\n    labelMat = new cv.Mat.zeros(edgeMat.rows, edgeMat.cols, edgeMat.type())\r\n    setRoi({ x: 0, y: 0, width: Math.min(400, src.width), height: Math.min(400, src.height) })\r\n    growValley(edgeRoi)\r\n}\r\n\r\nexport const getRoi = () => roiRect ? { ...roiRect } : undefined\r\n\r\n\r\nconst fitRange = (r: number[], n: number) => n < r[0] ? r[0] : (n > r[1] ? r[1] : n)\r\n\r\nconst restrictRoi = (roi: any) => {\r\n    roi.width = fitRange(RoiRange.width, roi.width)\r\n    roi.height = fitRange(RoiRange.height, roi.height)\r\n    roi.x = fitRange([0, bgMat.cols - roi.width], roi.x)\r\n    roi.y = fitRange([0, bgMat.rows - roi.height], roi.y)\r\n}\r\n\r\nexport const setRoi = (roi: any) => {\r\n    restrictRoi(roi)\r\n    if (roiRect) {\r\n        if (roi.x === roiRect.x && roi.y === roiRect.y && roi.width === roiRect.width && roi.height === roiRect.height) {\r\n            console.log(\"jerrr\")\r\n            return\r\n        }\r\n        display.delete()\r\n        bgRoi.delete()\r\n        edgeRoi.delete()\r\n        labelRoi.delete()\r\n    }\r\n    display = new cv.Mat.zeros(roi.height, roi.width, bgMat.type())\r\n    bgRoi = bgMat.roi(roi)\r\n    edgeRoi = edgeMat.roi(roi)\r\n    labelRoi = labelMat.roi(roi)\r\n    roiRect = roi\r\n}\r\n","import { Subject, BehaviorSubject } from 'rxjs'\r\nimport { tap, filter } from 'rxjs/operators'\r\n\r\nimport { edgeRoi, labelRoi, display, imshow, setVal, growValley, composeDisplay, dimBy, initMats, setRoi, ComposeConfig } from './model'\r\n\r\ntype MatUtil = {\r\n    setVal: (mat: any, pos: number[], val: number[]) => void\r\n    dimBy: (mat: any, amount: number) => void\r\n}\r\n\r\ntype MatUpdate = (mat: any, util: MatUtil) => void\r\n\r\nexport const DEFAULT_COMPOSE: ComposeConfig = {\r\n    showBg: true,\r\n    bgWeight: 1,\r\n    showEdge: true,\r\n    showEdgeValley: false,\r\n    edgeWeight: 0.4,\r\n    showLabel: true,\r\n    labelColor: [255, 255, 0, 255],\r\n    labelWeight: 0.8,\r\n}\r\n\r\nexport const composeUpdate = new BehaviorSubject<ComposeConfig>(DEFAULT_COMPOSE)\r\nexport const roiUpdate = new Subject<any>()\r\n\r\nexport const srcUpdate = new Subject<HTMLImageElement>()\r\nexport const edgeUpdate = new Subject<MatUpdate>()\r\nexport const labelUpdate = new Subject<MatUpdate>()\r\nexport const displayUpdate = new Subject<MatUpdate>()\r\n\r\nconst MatUtilImpl: MatUtil = {\r\n    setVal: setVal,\r\n    dimBy: dimBy,\r\n}\r\n\r\ncomposeUpdate\r\n    .pipe(\r\n        filter(() => display),\r\n    )\r\n    .subscribe(() => {\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nroiUpdate\r\n    .pipe(\r\n        tap(setRoi)\r\n    )\r\n    .subscribe(() => {\r\n        growValley(edgeRoi)\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nsrcUpdate\r\n    .pipe(\r\n        tap(initMats)\r\n    )\r\n    .subscribe(\r\n        () => displayUpdate.next((mat, util) => util.dimBy(mat, 96))\r\n    )\r\n\r\nedgeUpdate\r\n    .pipe(\r\n        filter(() => edgeRoi),\r\n        tap(update => update(edgeRoi, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        growValley(edgeRoi)\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\nlabelUpdate\r\n    .pipe(\r\n        filter(() => labelRoi),\r\n        tap(update => update(labelRoi, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        composeDisplay(display, composeUpdate.value)\r\n        imshow(display)\r\n    })\r\n\r\ndisplayUpdate\r\n    .pipe(\r\n        filter(() => display),\r\n        tap(() => composeDisplay(display, composeUpdate.value)),\r\n        tap(update => update(display, MatUtilImpl))\r\n    )\r\n    .subscribe(() => {\r\n        imshow(display)\r\n    })\r\n","import React, { useRef, SyntheticEvent, MouseEvent, KeyboardEvent, WheelEvent, useState, useCallback } from 'react'\nimport { Radio, Button } from 'antd'\nimport 'antd/dist/antd.css'\n\nimport { srcUpdate, edgeUpdate, labelUpdate, displayUpdate, composeUpdate, DEFAULT_COMPOSE, roiUpdate } from './controller'\nimport { edgeRoi, labelRoi, getVal, fallPos, selectTillBranch, fillSelect, needRepair, getRoi, outputLabel, RoiRange } from './model'\nimport './App.css'\n\ntype ActionMode = 0 | 1 | 2 | 3 | 4 | 5 | 6\nconst NO_ACTION: ActionMode = 0\nconst WIPE_EDGE: ActionMode = 1\nconst DRAW_EDGE: ActionMode = 2\nconst REPAIR_EDGE: ActionMode = 3\nconst FILL_LABEL: ActionMode = 4\nconst VIEW_LABEL: ActionMode = 5\nconst MOVE_CANVAS: ActionMode = 6\n\ntype CursorMode = 0 | 1 | 2 | 3\nconst DISABLED = 0\nconst FALLING = 1\nconst ADHERE = 2\nconst FLOATING = 3\n\nconst ValidCursorModes = {\n    0: [FALLING, ADHERE, FLOATING],\n    1: [FALLING, FLOATING],\n    2: [ADHERE, FLOATING],\n    3: [FLOATING],\n    4: [FLOATING],\n    5: [DISABLED],\n    6: [DISABLED],\n}\n\nconst CursorColors = {\n    0: [0, 0, 0, 0],\n    1: [0, 255, 255, 255],\n    2: [255, 0, 255, 255],\n    3: [255, 0, 0, 255],\n}\n\ntype EditHistory = {\n    action: ActionMode,\n    targets: number[][]\n}\nvar hist: EditHistory[] = []\n\nconst getRelPos = (canvas: HTMLCanvasElement, e: React.MouseEvent<HTMLCanvasElement>) => {\n    const rect = canvas.getBoundingClientRect()\n    return [(e.clientX - rect.left) / rect.width, (e.clientY - rect.top) / rect.height]\n}\n\nconst getRoiPos = (roi: any, relPos: number[]) => {\n    const res = relPos.map((p, i) => Math.floor(p * [roi.width, roi.height][i]))\n    return [res[1], res[0]]\n}\n\nexport default function App() {\n    const [isFocused, setFocused] = useState(false)\n    const [actionMode, setActionMode] = useState<ActionMode>(MOVE_CANVAS)\n    const [cursorMode, setCursorMode] = useState<CursorMode>(FALLING)\n    const [isMouseDown, setMouseDown] = useState(false)\n    const [movePrevPos, setMovePrevPos] = useState([-1, -1])\n    const imageSrc = useRef<HTMLImageElement>(null)\n    const labelOutput = useRef<HTMLCanvasElement>(null)\n\n    const downloadLabel = useCallback(() => {\n        const link = document.createElement('a')\n        link.download = 'label.png'\n        link.href = labelOutput.current?.toDataURL(\"image/png\")!\n        link.click();\n    }, [])\n\n    const doAction = useCallback((pos: number[], pressed = false) => {\n        let targets: number[][]\n        switch (cursorMode) {\n            case DISABLED:\n                targets = []\n                break\n            case FLOATING:\n                targets = [pos]\n                break\n            case FALLING:\n                targets = selectTillBranch(edgeRoi, fallPos(edgeRoi, pos))\n                break\n            case ADHERE:\n                targets = [fallPos(edgeRoi, pos, true)].filter(p => getVal(edgeRoi, p))\n        }\n        if (actionMode === MOVE_CANVAS) {\n            if (!isMouseDown) return\n            if (movePrevPos[0] === -1) return\n            const roi = getRoi()\n            roiUpdate.next({\n                ...roi,\n                x: roi.x + movePrevPos[1] - pos[1],\n                y: roi.y + movePrevPos[0] - pos[0],\n            })\n            hist.push({ action: MOVE_CANVAS, targets: [movePrevPos, pos] })\n        } else if (actionMode === NO_ACTION || !(isMouseDown || pressed)) {\n            displayUpdate.next((mat, util) => targets.forEach(p =>\n                util.setVal(mat, p, CursorColors[cursorMode]))\n            )\n        } else {\n            if (!targets.length) return\n            switch (actionMode) {\n                case WIPE_EDGE:\n                    targets = targets.filter(p => getVal(edgeRoi, p) === 255)\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [0])))\n                    break\n                case DRAW_EDGE:\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n                    break\n                case REPAIR_EDGE:\n                    const p = targets.pop()!\n                    const range = 20\n                    for (let i = p[0] - range; i < p[0] + range; i++)\n                        for (let j = p[1] - range; j < p[1] + range; j++)\n                            targets.push([i, j])\n                    targets = targets.filter(p => needRepair(edgeRoi, p))\n                    edgeUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n                    break\n                case FILL_LABEL:\n                    targets = fillSelect([edgeRoi, labelRoi], targets[0])\n                    labelUpdate.next((mat, util) => targets.forEach(p => util.setVal(mat, p, [255])))\n            }\n            if (!targets.length) return\n            hist.push({ action: actionMode, targets: targets })\n        }\n    }, [actionMode, cursorMode, isMouseDown, movePrevPos])\n\n    const undo = useCallback((h: EditHistory) => {\n        switch (h.action) {\n            case WIPE_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [255])))\n                break\n            case DRAW_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case REPAIR_EDGE:\n                edgeUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case FILL_LABEL:\n                labelUpdate.next((mat, util) => h.targets.forEach(p => util.setVal(mat, p, [0])))\n                break\n            case MOVE_CANVAS:\n                const roi = getRoi()\n                roiUpdate.next({\n                    ...roi,\n                    x: roi.x + h.targets[1][1] - h.targets[0][1],\n                    y: roi.y + h.targets[1][0] - h.targets[0][0],\n                })\n        }\n    }, [])\n\n    const setModes = useCallback((newCursorMode: CursorMode, newActionMode: ActionMode) => {\n        if (cursorMode !== newCursorMode) {\n            while (ValidCursorModes[newActionMode].indexOf(newCursorMode) < 0)\n                newCursorMode = (newCursorMode + 1) % 4 as CursorMode\n            setCursorMode(newCursorMode)\n        }\n        if (actionMode !== newActionMode) {\n            setActionMode(newActionMode)\n            switch (newActionMode) {\n                case WIPE_EDGE:\n                    setCursorMode(FALLING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, showEdgeValley: true, bgWeight: 0.5 })\n                    break\n                case DRAW_EDGE:\n                    setCursorMode(ADHERE)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.8, edgeWeight: 0.8 })\n                    break\n                case REPAIR_EDGE:\n                    setCursorMode(FLOATING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.8, edgeWeight: 0.8 })\n                    break\n                case FILL_LABEL:\n                    setCursorMode(FLOATING)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, bgWeight: 0.6 })\n                    break\n                case VIEW_LABEL:\n                    setCursorMode(DISABLED)\n                    composeUpdate.next({ ...DEFAULT_COMPOSE, showEdge: false, labelWeight: 0.4 })\n                    break\n                case MOVE_CANVAS:\n                    setCursorMode(DISABLED)\n                    composeUpdate.next(DEFAULT_COMPOSE)\n                    break\n                default:\n                    setCursorMode(FALLING)\n                    composeUpdate.next(DEFAULT_COMPOSE)\n            }\n        }\n    }, [cursorMode, actionMode])\n\n    const onImageLoad = useCallback((e: SyntheticEvent<HTMLImageElement, Event>) => {\n        srcUpdate.next(e.currentTarget)\n    }, [])\n\n    const onCanvasMouseEnter = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!getRoi()) return\n        displayUpdate.next((mat, util) => {\n            if (!isFocused) util.dimBy(mat, 48)\n        })\n    }, [isFocused])\n\n    const onCanvasMouseLeave = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!getRoi()) return\n        setMouseDown(false)\n        setMovePrevPos([-1, -1])\n        displayUpdate.next((mat, util) => {\n            if (!isFocused) util.dimBy(mat, 96)\n        })\n    }, [isFocused])\n\n    const onCanvasMouseMove = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!getRoi()) return\n        if (!isFocused) return\n        const pos = getRoiPos(getRoi(), getRelPos(e.currentTarget, e))\n        if (pos.toString() === movePrevPos.toString()) return\n        doAction(pos)\n        setMovePrevPos(pos)\n    }, [isFocused, movePrevPos, doAction])\n\n    const onCanvasMouseDown = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!getRoi()) return\n        setMovePrevPos([-1, -1])\n        if (!isFocused) return\n        setMouseDown(true)\n        if (actionMode === NO_ACTION) return\n        const pos = getRoiPos(getRoi(), getRelPos(e.currentTarget, e))\n        doAction(pos, true)\n    }, [isFocused, actionMode, doAction])\n\n    const onCanvasMouseUp = useCallback((e: MouseEvent<HTMLCanvasElement>) => {\n        if (!getRoi()) return\n        setMouseDown(false)\n    }, [])\n\n    const onCanvasKeyPress = useCallback((e: KeyboardEvent<HTMLCanvasElement>) => {\n        if (!getRoi()) return\n        setMovePrevPos([-1, -1])\n        let newCursorMode: CursorMode = cursorMode, newActionMode: ActionMode = actionMode\n        switch (e.key) {\n            case \"f\":\n                newCursorMode = (cursorMode + 1) % 4 as CursorMode\n                break\n            case \"z\":\n                if (hist.length) undo(hist.pop()!)\n                break\n            case \"s\":\n                outputLabel()\n                downloadLabel()\n                break\n            case \"w\":\n                newActionMode = WIPE_EDGE\n                break\n            case \"e\":\n                newActionMode = DRAW_EDGE\n                break\n            case \"r\":\n                newActionMode = REPAIR_EDGE\n                break\n            case \"d\":\n                newActionMode = FILL_LABEL\n                break\n            case \"v\":\n                newActionMode = VIEW_LABEL\n                break\n            case \"q\":\n                newActionMode = MOVE_CANVAS\n                break\n            default:\n                newActionMode = NO_ACTION\n        }\n        setModes(newCursorMode, newActionMode)\n    }, [actionMode, cursorMode, undo, setModes, downloadLabel])\n\n    const onCanvasFocus = useCallback(() => {\n        if (!getRoi()) return\n        setFocused(true)\n        displayUpdate.next(() => { })\n    }, [])\n\n    const onCanvasBlur = useCallback(() => {\n        if (!getRoi()) return\n        setFocused(false)\n        setMouseDown(false)\n        setMovePrevPos([-1, -1])\n        displayUpdate.next((mat, util) => util.dimBy(mat, 96))\n    }, [])\n\n    const onCanvasWheel = useCallback((e: WheelEvent<HTMLCanvasElement>) => {\n        if (!getRoi()) return\n        if (actionMode !== MOVE_CANVAS) return\n        const roi = getRoi()\n        e.preventDefault()\n        const relPos = getRelPos(e.currentTarget, e)\n        const oldPos = getRoiPos(roi, relPos)\n        const newRoi = {\n            ...roi,\n            width: e.deltaY > 0 ? Math.ceil(roi.width * 1.05) : Math.floor(roi.width * 0.95),\n            height: e.deltaY > 0 ? Math.ceil(roi.height * 1.05) : Math.floor(roi.height * 0.95),\n        }\n        if (newRoi.width < RoiRange.width[0] || newRoi.width > RoiRange.width[1] ||\n            newRoi.height < RoiRange.height[0] || newRoi.height > RoiRange.height[1])\n            return\n        const newPos = getRoiPos(newRoi, relPos)\n        roiUpdate.next({\n            ...newRoi,\n            x: roi.x + oldPos[1] - newPos[1],\n            y: roi.y + oldPos[0] - newPos[0],\n        })\n    }, [actionMode])\n\n    return (\n        <div className=\"App\">\n            <div className=\"input\">\n                <img id=\"imageSrc\" alt={\"Canvas Input\"} ref={imageSrc} onLoad={onImageLoad} style={{ display: \"none\" }} />\n                <input type=\"file\" id=\"fileInput\" name=\"file\" onChange={(e) => {\n                    imageSrc.current!.src = URL.createObjectURL(e.target.files![0]);\n                }} />\n            </div>\n            <div className=\"radio\">\n                <span>Action: </span>\n                <Radio.Group value={actionMode} onChange={(e) => setModes(cursorMode, e.target.value)} disabled={!getRoi()}>\n                    <Radio.Button value={NO_ACTION}>No Action</Radio.Button>\n                    <Radio.Button value={MOVE_CANVAS}>Move Canvas (Q)</Radio.Button>\n                    <Radio.Button value={WIPE_EDGE}>Wipe Edge (W)</Radio.Button>\n                    <Radio.Button value={DRAW_EDGE}>Draw Edge (E)</Radio.Button>\n                    <Radio.Button value={REPAIR_EDGE}>Repair Edge (R)</Radio.Button>\n                    <Radio.Button value={FILL_LABEL}>Fill Label (D)</Radio.Button>\n                    <Radio.Button value={VIEW_LABEL}>View Label (V)</Radio.Button>\n                </Radio.Group>\n            </div>\n            <div className=\"radio\">\n                <span>Cursor (F): </span>\n                <Radio.Group value={cursorMode} onChange={(e) => setModes(e.target.value, actionMode)} disabled={!getRoi()}>\n                    <Radio.Button value={FALLING} disabled={ValidCursorModes[actionMode].indexOf(FALLING) < 0}>Fall to Edge</Radio.Button>\n                    <Radio.Button value={ADHERE} disabled={ValidCursorModes[actionMode].indexOf(ADHERE) < 0}>Adhere to Edge</Radio.Button>\n                    <Radio.Button value={FLOATING} disabled={ValidCursorModes[actionMode].indexOf(FLOATING) < 0}>Floating</Radio.Button>\n                </Radio.Group>\n                <Button className=\"button\" type=\"danger\" ghost onClick={() => { if (hist.length) undo(hist.pop()!) }} disabled={!getRoi()}>Undo (Z)</Button>\n                <Button className=\"button\" type=\"primary\" ghost onClick={() => { outputLabel(); downloadLabel() }} disabled={!getRoi()}>Save Label (S)</Button>\n            </div>\n            <div className=\"canvas\">\n                <canvas\n                    id=\"canvas\"\n                    className={actionMode === MOVE_CANVAS ? \"moving\" : \"\"}\n                    onMouseEnter={onCanvasMouseEnter}\n                    onMouseLeave={onCanvasMouseLeave}\n                    onMouseMove={onCanvasMouseMove}\n                    onMouseDown={onCanvasMouseDown}\n                    onMouseUp={onCanvasMouseUp}\n                    onKeyPress={onCanvasKeyPress}\n                    onFocus={onCanvasFocus}\n                    onBlur={onCanvasBlur}\n                    onWheel={onCanvasWheel}\n                    tabIndex={1000}\n                />\n            </div>\n            <canvas id=\"output\" ref={labelOutput} />\n        </div>\n    );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}